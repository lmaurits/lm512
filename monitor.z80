;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMAND LINE INTERFACE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Monitor:
MonitorLoop:
; Infinite loop of read, parse, dispatch
	ld		hl, monpromptstr
	call		PrintStringA
	ld		hl, mon_linebuf
	call		ReadLineA
	jr		nz, Monitor ; User stopped input using Ctrl-C
	ld		hl, mon_linebuf
	ld		a, (hl)
	cp		"\0"
	jr		z, Monitor
	call		MonitorHandleLine
	jr		MonitorLoop
monpromptstr:
	defm		"$ \0"

MonitorHandleLine:
	ld		hl, mon_linebuf	
	call		ConvertToUpper
	ld		bc, mon_argc
	call		ParseLine
	ld		bc, mondispatch_table
	call		Dispatch
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND DISPATCH
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Command strings

cfloadstr:	defm "CFLOAD\0"
cfsavestr:	defm "CFSAVE\0"
continuestr:	defm "CONTINUE\0"
bankstr:	defm "BANK\0"
dumpstr:	defm "DUMP\0"
instr:		defm "IN\0"
helpstr:	defm "HELP\0"
jumpstr:	defm "JUMP\0"
memcpystr:	defm "MEMCPY\0"
memedstr:	defm "MEMED\0"
outstr:		defm "OUT\0"
nullstr:	defm "\0"

; Table linking command strings to function entry points
mondispatch_table:
	defw cfloadstr, CfLoad
	defw cfsavestr, CfSave
	defw continuestr, Continue
	defw bankstr, Bank
	defw dumpstr, Dump
	defw instr, In
	defw helpstr, Help
	defw jumpstr, Jump
	defw memcpystr, Memcpy
	defw memedstr, Memed
	defw outstr, Out
	defw nullstr, What

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMANDS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Bank:
	ld		a, (mon_argc)
	cp		1
	jr		z, Bank00
	ld		hl, BankErrStr
	call		PrintStringA
	ret
BankErrStr:
	defm		"BANK expects exactly one arg (2 digit hex bank)\r\n\0"
Bank00:
	ld		hl, (mon_argv)
	call		ValidateValue
	jr		z, Bank01
	ret
Bank01:
	call		Read8bit	
	out		(0), a
	ret
FooStr: defm		"Foo\r\n\0"
BarStr: defm		"Bar\r\n\0"
BazStr: defm		"Baz\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfLoad:
	; Check argument count
	ld		a, (mon_argc)
	cp		3
	jr		z, CfLoad00
	ld		hl, CfLoadErrorStr
	call		PrintStringA
	ret
CfLoad00:
	; Validate address
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	; Validate LBA
	ld		hl, (mon_argv+2)
	call		ValidateSector
	ret		nz
	; Validate sector count
	ld		hl, (mon_argv+4)
	call		ValidateValue
	ret		nz
	; Parse address
	ld		hl, (mon_argv)
	call		Read16bit
	push		bc
	; Parse LBA
	ld		hl, (mon_argv+2)
	call		Read16bit
	push		bc
	call		Read16bit
	push		bc
	; Parse sector count
	ld		hl, (mon_argv+4)
	call		Read8bit
	; Put everything in appropriate registers
	pop		bc
	pop		de
	pop		hl
	; Do it
	call		CF_READ
	ret
CfLoadErrorStr:
	defm		"CFLOAD expects exactly three args (A 4 digit hex destination address, a 6 digit hex start sector and a 2 digit hex sector count)\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfSave:
	; Check argument count
	ld		a, (mon_argc)
	cp		3
	jr		z, CfSave00
	ld		hl, CfSaveErrorStr
	call		PrintStringA
	ret
CfSave00:
	; Validate sector
	ld		hl, (mon_argv)
	call		ValidateSector
	ret		nz
	; Validate address
	ld		hl, (mon_argv+2)
	call		ValidateAddress
	ret		nz
	; Validate value
	ld		hl, (mon_argv+4)
	call		ValidateValue
	ret		nz
	; Parse LBA
	ld		hl, (mon_argv)
	call		Read16bit
	push		bc
	call		Read16bit
	push		bc
	; Parse mem address
	ld		hl, (mon_argv+2)
	call		Read16bit
	push		bc
	; Parse sector count
	ld		hl, (mon_argv+4)
	call		Read8bit
	; Put everything in appropriate registers
	pop		hl
	pop		bc
	pop		de
	; Do it
	call		CF_WRITE
	ret
CfSaveErrorStr:
	defm		"CFSAVE expects exactly three args (a 6 digit hex start sector, a 4 digit start address and a 2 digit hex sector count)\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Continue:
	; Pop the return address which leads back to the monitor loop
	pop		hl
	pop		hl
	; Now return to wherever we were called from
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Dump:
	; Check argument count
	ld		a, (mon_argc)
	cp		1
	jr		z, Dump00
	ld		hl, DumpArgcErrorStr
	call		PrintStringA
	ret
DumpArgcErrorStr:
	defm		"DUMP expects exactly one arg (4 digit hex address)\r\n\0"
Dump00:
	ld		hl, (mon_argv)
	call		ValidateAddress
	jr		z, Dump01
	ret
Dump01:
	call		Read16bit	; Read address into BC
	ld		d, b
	ld		e, c
DumpPreOuter:
	ld		b, 16
	push		bc
DumpOuter:
	ld		hl, mon_linebuf
	ld		b, 16
DumpInner:
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\t"
	inc		hl
DumpInner2:
	ld		a, (de)		; Read from BC to A
	inc		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	dec		b
	ld		a, b
	cp		0
	jr		z, Dump03
	jr		DumpInner2
Dump03:
	call		TerminateLine
	ld		hl, mon_linebuf
	call		PrintStringA
	pop		bc
	dec		b
	ld		a, b
	cp		0
	jr		z, Dump04
	push		bc
	jr		DumpOuter
Dump04:
	ld		hl, DumpContinueStr
	call		PrintStringA
	call		SERIAL_READ_A
	push		af
	call		ClearLeft
	ld		a, "\r"
	call		SERIAL_WRITE_A
	pop		af
	cp		" "
	jr		z, DumpPreOuter
	cp		0x03	
	ret		z
	jr		Dump04
	
DumpContinueStr:
	defm		"(press SPACE to continue, Ctrl-C to end)\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

In:
	ld		a, (mon_argc)
	cp		1
	jr		z, In00
	ld		hl, InErrStr
	call		PrintStringA
	ret
InErrStr:
	defm		"IN expects exactly one arg (2 digit hex address)\r\n\0"
In00:
	call		Read8bit
	ld		c, a
	in		a, (c)
	ld		hl, mon_linebuf	; Point to start of output
	call		StrfHex		; Write hex string
	call		TerminateLine	; Add \n\r\0
	ld		hl, mon_linebuf	; Print output
	call		PrintStringA
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Help:
	ld hl, helpmessage
	call PrintStringA
	ret
	helpmessage:	defm "LM-512 Monitor commands:\n\r"
	defm "BANK PG: Switch highest 32KB to bank PG.\n\r"
	defm "CFLOAD ADR STARTSEC SECS: Read SECS 512 byte sectors from CF card, starting from STARTSEC, to address ADR.\n\r"
	defm "CFSAVE STARTSEC ADR SECS: Write SECS 512 byte sectors to CF card, starting from address, to sector STARTSEC.\n\r"
	defm "CONTINUE: Resume program execution.\n\r"
	defm "DUMP ADR: Dump 256 bytes of memory starting from ADR in hex format.\n\r"
	defm "HELP: Print this help message.\n\r"
	defm "IN PORT: Read byte from given I/O port.\n\r"
	defm "JUMP ADR: Jump to address.\n\r"
	defm "MEMCPY DEST SRC BYTES: Copy BYTES consecutive bytes from SRC to DEST\n\r"
	defm "MEMED ADR: Edit memory byte by byte, starting from ADR.  Press Ctrl-C to end editing.\n\r"
	defm "OUT PORT VAL: Write byte VAL to given I/O port.\n\r"
	defm "\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Jump:
	ld		a, (mon_argc)
	cp		1
	jr		z, Jump00
	ld		hl, JumpErrStr
	call		PrintStringA
	ret
JumpErrStr:
	defm		"JUMP expects exactly one arg (4 digit hex address)\r\n\0"
Jump00:
	ld		hl, (mon_argv)
	call		ValidateAddress
	jr		z, Jump01
	ret
Jump01:
	call		Read16bit
	ld		h, b
	ld		l, c
	jp		(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Memcpy:
	ld		a, (mon_argc)
	cp		3
	jr		z, Memcpy00
	ld		hl, MemcpyArgcErrStr
	call		PrintStringA
	ret
MemcpyArgcErrStr:
	defm		"MEMCPY expects exactly three args (Two 4 digit hex addresses and one 4 digit hex byte count\r\n\0"
Memcpy00:
	; Validate, parse and push destination
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	push		bc	
	; Validate, parse and push source
	ld		hl, (mon_argv+2)
	call		ValidateAddress
	jr		z, Memcpy01
	pop		bc
	ret
Memcpy01:
	call		Read16bit
	push		bc	
	; Validate, parse and push count
	ld		hl, (mon_argv+4)
	call		ValidateAddress
	jr		z, Memcpy02
	pop		bc
	pop		bc
	ret
Memcpy02:
	call		Read16bit
	pop		hl
	pop		de
	ldir
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Memed:
	ld		a, (mon_argc)
	cp		1
	jr		z, Memed00
	ld		hl, MemedArgcErrStr
	call		PrintStringA
	ret
MemedArgcErrStr:
	defm		"MEMED expects exactly one args (a 4 digit hex addresses\r\n\0"
Memed00:
	; Validate, parse and push destination
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	ld		d, b
	ld		e, c
Memed01:
	ld		hl, mon_linebuf
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		a, (de)
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		(hl), "\0"
	ld		hl, mon_linebuf
	call		PrintStringA
	call		ReadLineA
	ret		nz	; User hit Ctrl-C
	ld		a, (hl)
	cp		"\0"
	jr		z, Memed02
	call		ConvertToUpper	
	call		ValidateValue
	jr		nz, Memed01
	push		de
	call		Read8bit
	pop		de
	ld		(de), a
Memed02:
	inc		de
	jr		Memed01
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Out:
	ld		a, (mon_argc)
	cp		2
	jr		z, Out00
	ld		hl, OutErrStr
	call		PrintStringA
	ret
OutErrStr:
	defm		"OUT expects exactly two args (A 2 digit hex address, a 2 digit hex value)\r\n\0"
Out00:
	ld		hl, (mon_argv)
	call		ValidateValue
	jr		z, Out01
	ret
Out01:
	ld		hl, (mon_argv+2)
	call		ValidateValue
	jr		z, Out02
	ret
Out02:
	ld		hl, (mon_argv)
	call		Read8bit
	ld		c, a
	ld		hl, (mon_argv+2)
	call		Read8bit
	out		(c), a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

What:
	ld hl, whatstr
	call PrintStringA
	ret
	whatstr: defm "What?\n\r\0"
