;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMAND LINE INTERFACE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Monitor:
	; Backup stack pointer
	ld		(mon_stack_backup), SP
	; Save all registers
	ld		sp, mon_reg_stack+1
	push		af
	push		bc
	push		de
	push		hl
	ex		af, af'
	exx
	push		af
	push		bc
	push		de
	push		hl
	ex		af, af'
	exx
	push		ix
	push		iy
	; Restore original stack pointer
	ld		SP, (mon_stack_backup)
MonitorStart:
	ld		hl, monwelcomestr
	call		PrintStringA
	call		Registers
MonitorLoop:
; Infinite loop of read, parse, dispatch
	ld		hl, monpromptstr
	call		PrintStringA
	ld		hl, mon_linebuf
	call		ReadLineA
	jr		nz, MonitorLoop ; User stopped input using Ctrl-C
	ld		hl, mon_linebuf
	ld		a, (hl)
	cp		"\0"
	jr		z, MonitorLoop
	call		MonitorHandleLine
	jr		MonitorLoop
MonitorExit:
	; Backup stack pointer
	ld		(mon_stack_backup), SP
	; Restore all registers
	ld		sp, mon_reg_stack-19
	pop		iy
	pop		ix
	ex		af, af'
	exx
	pop		hl
	pop		de
	pop		bc
	pop		af
	ex		af, af'
	exx
	pop		hl
	pop		de
	pop		bc
	pop		af
	; Restore original stack pointer
	ld		SP, (mon_stack_backup)
	ret
monwelcomestr:
	defm		"*** MONITOR\r\n\0"
monpromptstr:
	defm		"$ \0"

MonitorHandleLine:
	ld		hl, mon_linebuf	
	call		ConvertToUpper
	ld		bc, mon_argc
	call		ParseLine
	ld		bc, mondispatch_table
	call		Dispatch
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND DISPATCH
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Command strings

cfloadstr:	defm "CFLOAD\0"
cfsavestr:	defm "CFSAVE\0"
continuestr:	defm "CONTINUE\0"
bankstr:	defm "BANK\0"
dumpstr:	defm "DUMP\0"
instr:		defm "IN\0"
helpstr:	defm "HELP\0"
jumpstr:	defm "JUMP\0"
memcpystr:	defm "MEMCPY\0"
memedstr:	defm "MEMED\0"
regstr:		defm "REGISTERS\0"
stackstr:	defm "STACK\0"
outstr:		defm "OUT\0"
nullstr:	defm "\0"

; Table linking command strings to function entry points
mondispatch_table:
	defw cfloadstr, CfLoad
	defw cfsavestr, CfSave
	defw continuestr, Continue
	defw bankstr, Bank
	defw dumpstr, Dump
	defw instr, In
	defw helpstr, Help
	defw jumpstr, Jump
	defw memcpystr, Memcpy
	defw memedstr, Memed
	defw outstr, Out
	defw regstr, Registers
	defw stackstr, Stack
	defw nullstr, What

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMANDS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Bank:
	ld		a, (mon_argc)
	cp		1
	jr		z, Bank00
	;; Argc error
	ld		hl, message_buffer
	ld		de, bankstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, BankArgsStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
BankArgsStr:
	defm		"(mem bank).\r\n\0"
Bank00:
	ld		hl, (mon_argv)
	call		ValidateValue
	jr		z, Bank01
	ret
Bank01:
	call		Read8bit	
	out		(0), a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfLoad:
	; Check argument count
	ld		a, (mon_argc)
	cp		3
	jr		z, CfLoad00
	;; Argc error
	ld		hl, message_buffer
	ld		de, cfloadstr
	call		StrCpy
	ld		de, ExpectsExactlyThreeArgsStr
	call		StrCpy
	ld		de, CfLoadArgStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
CfLoad00:
	; Validate address
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	; Validate LBA
	ld		hl, (mon_argv+2)
	call		ValidateSector
	ret		nz
	; Validate sector count
	ld		hl, (mon_argv+4)
	call		ValidateValue
	ret		nz
	; Parse address
	ld		hl, (mon_argv)
	call		Read16bit
	push		bc
	; Parse LBA
	ld		hl, (mon_argv+2)
	call		Read16bit
	push		bc
	call		Read16bit
	push		bc
	; Parse sector count
	ld		hl, (mon_argv+4)
	call		Read8bit
	; Put everything in appropriate registers
	pop		bc
	pop		de
	pop		hl
	; Do it
	call		CF_READ
	ret
ExpectsExactlyThreeArgsStr:
	defm		" expects exactly three args \r\n\0"
CfLoadArgStr:
	defm		"(mem address, start sector, sector count)\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfSave:
	; Check argument count
	ld		a, (mon_argc)
	cp		3
	jr		z, CfSave00
	;; Argc error
	ld		hl, message_buffer
	ld		de, cfsavestr
	call		StrCpy
	ld		de, ExpectsExactlyThreeArgsStr
	call		StrCpy
	ld		de, CfSaveArgStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
CfSave00:
	; Validate sector
	ld		hl, (mon_argv)
	call		ValidateSector
	ret		nz
	; Validate address
	ld		hl, (mon_argv+2)
	call		ValidateAddress
	ret		nz
	; Validate value
	ld		hl, (mon_argv+4)
	call		ValidateValue
	ret		nz
	; Parse LBA
	ld		hl, (mon_argv)
	call		Read16bit
	push		bc
	call		Read16bit
	push		bc
	; Parse mem address
	ld		hl, (mon_argv+2)
	call		Read16bit
	push		bc
	; Parse sector count
	ld		hl, (mon_argv+4)
	call		Read8bit
	; Put everything in appropriate registers
	pop		hl
	pop		bc
	pop		de
	; Do it
	call		CF_WRITE
	ret
CfSaveArgStr:
	defm		"(start sector, mem address, sector count)\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Continue:
	; Pop the return address which leads back to the monitor loop
	pop		hl	; Break out of Dispatch
	pop		hl	; Break out of MonitorHandleLine
	; Break out of monitor loop
	jp		MonitorExit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Dump:
	; Check argument count
	ld		a, (mon_argc)
	cp		1
	jr		z, Dump00
	;; Argc error
	ld		hl, message_buffer
	ld		de, dumpstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, AddressStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
Dump00:
	ld		hl, (mon_argv)
	call		ValidateAddress
	jr		z, Dump01
	ret
Dump01:
	call		Read16bit	; Read address into BC
	ld		d, b
	ld		e, c
DumpPreOuter:
	ld		b, 16
	push		bc
DumpOuter:
	ld		hl, mon_linebuf
	ld		b, 16
DumpInner:	; Print address
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\t"
	inc		hl
DumpInner2:
	ld		a, (de)		; Read from DE to A
	inc		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	dec		b
	ld		a, b
	cp		0
	jr		z, DumpASCII
	jr		DumpInner2
DumpASCII:
	ld		(hl), "\t"
	inc		hl
; Rewind
	ld		b, 16
DumpDecLoop:
	dec		de
	djnz		DumpDecLoop
	ld		b, 16
DumpInner3:
	ld		a, (de)		; Read from DE to A
	inc		de
	cp		32
	jr		z, HandlePrintable
	jr		c, HandleNonprintable
	cp		127
	jr		z, HandlePrintable
	jr		c, HandlePrintable
	jr		HandleNonprintable
HandlePrintable:
	ld		(hl), a
	inc		hl
	jr		DumpCont
HandleNonprintable:
	ld		(hl), "."
	inc		hl
	jr		DumpCont
DumpCont:
	dec		b
	ld		a, b
	cp		0
	jr		z, Dump03
	jr		DumpInner3
Dump03:
	call		TerminateLine
	ld		hl, mon_linebuf
	call		PrintStringA
	pop		bc
	dec		b
	ld		a, b
	cp		0
	jr		z, Dump04
	push		bc
	jr		DumpOuter
Dump04:
	ld		hl, DumpContinueStr
	call		PrintStringA
	call		SERIAL_READ_A
	push		af
	call		ClearLeft
	ld		a, "\r"
	call		SERIAL_WRITE_A
	pop		af
	cp		" "
	jr		z, DumpPreOuter
	cp		0x03	
	ret		z
	jr		Dump04
	
DumpContinueStr:
	defm		"(press SPACE to continue, Ctrl-C to end)\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

In:
	ld		a, (mon_argc)
	cp		1
	jr		z, In00
	;; Argc error
	ld		hl, message_buffer
	ld		de, instr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, InArgsStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
InArgsStr:
	defm		"(port)\r\n\0"
In00:
	ld		hl, (mon_argv)
	call		Read8bit
	ld		c, a
	in		a, (c)
	ld		hl, mon_linebuf	; Point to start of output
	call		StrfHex		; Write hex string
	call		TerminateLine	; Add \n\r\0
	ld		hl, mon_linebuf	; Print output
	call		PrintStringA
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Help:
	ld hl, helpmessage
	call PrintStringA
	ret
	helpmessage:	defm "Monitor commands:\n\r"
	defm "BANK PG: Bank switch top 32KB.\n\r"
	defm "CFLOAD ADDR SECT NSECS: Read sectors from CF.\n\r"
	defm "CFSAVE SECT ADDR NSECS: Write sectors to CF.\n\r"
	defm "CONTINUE: Resume program execution.\n\r"
	defm "DUMP ADDR: Hexdump 256 bytes of memory.\n\r"
	defm "IN PORT: Read byte from I/O port.\n\r"
	defm "JUMP ADDR: Jump to address.\n\r"
	defm "MEMCPY DEST SRC NBYTES: Copy memory\n\r"
	defm "MEMED ADDR: Edit memory\n\r"
	defm "OUT PORT VAL: Write byte to I/O port.\n\r"
	defm "REGISTERS: Register dump.\n\r"
	defm "STACK: Stack trace.\n\r"
	defm "\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Jump:
	ld		a, (mon_argc)
	cp		1
	jr		z, Jump00
	;; Argc error
	ld		hl, message_buffer
	ld		de, jumpstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, AddressStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
Jump00:
	ld		hl, (mon_argv)
	call		ValidateAddress
	jr		z, Jump01
	ret
Jump01:
	call		Read16bit
	ld		h, b
	ld		l, c
	jp		(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Memcpy:
	ld		a, (mon_argc)
	cp		3
	jr		z, Memcpy00
	;; Argc error
	ld		hl, message_buffer
	ld		de, memcpystr
	call		StrCpy
	ld		de, ExpectsExactlyThreeArgsStr
	call		StrCpy
	ld		de, MemcpyArgStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
MemcpyArgStr:
	defm		"(dest address, src address, 4 digit byte count).\r\n\0"
Memcpy00:
	; Validate, parse and push destination
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	push		bc	
	; Validate, parse and push source
	ld		hl, (mon_argv+2)
	call		ValidateAddress
	jr		z, Memcpy01
	pop		bc
	ret
Memcpy01:
	call		Read16bit
	push		bc	
	; Validate, parse and push count
	ld		hl, (mon_argv+4)
	call		ValidateAddress
	jr		z, Memcpy02
	pop		bc
	pop		bc
	ret
Memcpy02:
	call		Read16bit
	pop		hl
	pop		de
	ldir
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Memed:
	ld		a, (mon_argc)
	cp		1
	jr		z, Memed00
	;; Argc error
	ld		hl, message_buffer
	ld		de, memedstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, AddressStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
Memed00:
	; Validate, parse and push destination
	ld		hl, (mon_argv)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	ld		d, b
	ld		e, c
Memed01:
	ld		hl, mon_linebuf
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		a, (de)
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		(hl), "\0"
	ld		hl, mon_linebuf
	call		PrintStringA
	call		ReadLineA
	ret		nz	; User hit Ctrl-C
	ld		a, (hl)
	cp		"\0"
	jr		z, Memed02
	call		ConvertToUpper	
	call		ValidateValue
	jr		nz, Memed01
	push		de
	call		Read8bit
	pop		de
	ld		(de), a
Memed02:
	inc		de
	jr		Memed01
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Registers:
	ld		hl, reg_labels
	call		PrintStringA
	ld		de, mon_reg_stack
	ld		hl, mon_linebuf
	call		RegisterPrint

	ld		hl, alt_reg_labels
	call		PrintStringA
	ld		hl, mon_linebuf
	call		RegisterPrint

	ld		hl, i_reg_labels
	call		PrintStringA
	ld		hl, mon_linebuf
	ld		a, (de)
	dec		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		a, (de)
	dec		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		a, (de)
	dec		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	ld		a, (de)
	call		StrfHex
	ld		(hl), " "
	inc		hl
	call		TerminateLine
	ld		hl, mon_linebuf
	call		PrintStringA

	ret

RegisterPrint:
	ld		b, 8
RegisterPrintLoop:
	ld		a, (de)
	dec		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	djnz		RegisterPrintLoop
	call		TerminateLine
	ld		hl, mon_linebuf
	call		PrintStringA
	ret

reg_labels:
	defm		"A  F  B  C  D  E  H  L\r\n\0"
alt_reg_labels:
	defm		"A' F' B' C' D' E' H' L'\r\n\0"
i_reg_labels:
	defm		"IX    IY\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Out:
	ld		a, (mon_argc)
	cp		2
	jr		z, Out00
	;; Argc error
	ld		hl, message_buffer
	ld		de, outstr
	call		StrCpy
	ld		de, ExpectsExactlyTwoArgsStr
	call		StrCpy
	ld		de, OutArgsStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
OutArgsStr:
	defm		"(port, value).\r\n\0"
Out00:
	ld		hl, (mon_argv)
	call		ValidateValue
	jr		z, Out01
	ret
Out01:
	ld		hl, (mon_argv+2)
	call		ValidateValue
	jr		z, Out02
	ret
Out02:
	ld		hl, (mon_argv)
	call		Read8bit
	ld		c, a
	push		bc
	ld		hl, (mon_argv+2)
	call		Read8bit
	pop		bc
	out		(c), a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Stack:
	ld		de, (mon_stack_backup)
	ld		b, 8
StackLoop:
	push		bc
	ld		hl, mon_linebuf
	inc		de
	ld		a, (de)
	call		StrfHex
	dec		de
	ld		a, (de)
	inc		de
	inc		de
	call		StrfHex
	call		TerminateLine
	ld		hl, mon_linebuf
	call		PrintStringA
	pop		bc
	djnz		StackLoop
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

What:
	ld hl, whatstr
	call PrintStringA
	ret
	whatstr: defm "What?\n\r\0"
