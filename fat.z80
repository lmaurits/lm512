InitFAT:
ReadMBR:
	; The MBR is the first sector of the disk.
	ld	hl, fat_sector_buffer
	ld	a, 01	; MBR is one sector
	ld	bc, 00	; MBR starts at sector 0
	ld	de, 00
	rst	0x20	; call CF_READ
ReadVBR:
	; The MBR contains the address of the first sector of partition 1
	; Store this in memory for future reference, then read that sector
	; (the VBR) into memory.
	ld	ix, fat_sector_buffer+0x1BE
	ld	c, (ix+0x08)
	ld	a, c
	ld	(partition_start_sec+0), a
	ld	b, (ix+0x09)
	ld	a, b
	ld	(partition_start_sec+1), a
	ld	e, (ix+0x0A)
	ld	a, e
	ld	(partition_start_sec+2), a
	ld	d, (ix+0x0B)
	ld	a, d
	ld	(partition_start_sec+3), a
	ld	a, 01	; VBR is one sector
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
ReadBPB:
	; The VBR contains essential information on the FAT filesystem
	; Store all of this in memory for future reference
	ld	hl, fat_sector_buffer+0x0B
	ld	de, fat_spec_table
	ld	bc, 13
	ldir

ComputeSectors:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Assuming that the fat_spec_table is correctly populated, compute
; the address of the first sector of the root directory, and load
; it into the sector buffer.  Note that this function is currently
; LAZY, i.e. it makes assumptions about the FAT spec, e.g. that there
; are 2 FATs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Compute the starting sectors of various regions of the FAT
	ld	hl, (partition_start_sec)	; Start HL at partition start
	ld	bc, (reserved_sectors)
	add	hl, bc				; Skip past reserved sectors
	ld	(start_of_fat), hl
	ld	bc, (sectors_per_fat)
	add	hl, bc			; Skip past first FAT
	add	hl, bc			; Skip past second FAT
	ld	(start_of_root_dir), hl
	ld	bc, 32			; Skip past root directory - LAZY
	add	hl, bc
	ld	(start_of_data), hl
	ret

;;;;;;;;;;;;

ClusterToSector:
	; Load b,c,d,e with the sector corresponding to the cluster in hl
	ld	bc, (start_of_data)
	add	hl, bc			; add 1 sector per cluster
	or	a			; Clear carry flag
	ld	bc, 2
	sbc	hl, bc			; Subtract 2 (clusters 0, 1 don't map to data region)
	ld	b, h
	ld	c, l
	ld	de, 0
	ret

;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; FAT handling stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ResetFat:
	; Read first sector of FAT off disk
	ld	hl, fat_buffer
	ld	bc, (start_of_fat)
	ld	(fat_sector), bc
ResetFatAdvanceSectorEntryPoint:
	ld	de, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ
	; Skip over reserved clusters
	ld	hl, fat_buffer
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	; Update indexes
	ld	(fat_mem_index), hl
	ld	hl, 0x0002
	ld	(fat_cluster), hl
	ld	a, 2
	ld	(fat_index), a
	ret

;;;;;;;;;;;;

AdvanceCluster:
	;; Increment cluster
	ld	hl, (fat_cluster)
	inc	hl
	ld	(fat_cluster), hl

	;; Increment index and figure out if we need to read new sec
	ld	a, (fat_index)
	inc	a
	cp	32	; 32 clusters / sector
	jr	z, AdvanceCluster_ReadNewSector
	ld	(fat_index), a

	;; Increment FAT memory index
	ld	hl, (fat_mem_index)
	inc	hl
	inc	hl
	ld	(fat_mem_index), hl

	ret
AdvanceCluster_ReadNewSector:
	;; Read new sector
	ld	hl, fat_buffer
	ld	bc, (fat_sector)
	inc	bc
	ld	(fat_sector), bc
	ld	de, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ

	;; Reset index and mem_index
	ld	a, 0
	ld	(fat_index), a
	ld	hl, fat_buffer
	ld	(fat_mem_index), hl
	ret

;;;;;;;;;;;;

FindFirstAvailCluster:
	call	ResetFat
	ld	hl, (fat_mem_index)
	ld	a, (hl)
	inc	hl
	ld	b, (hl)
	or	b
	cp	0
	ret	z
	call	FindNextAvailCluster

;;;;;;;;;;;;

FindNextAvailCluster:
	call	AdvanceCluster
	ld	hl, (fat_mem_index)
	ld	a, (hl)
	inc	hl
	ld	b, (hl)
	or	b
	cp	0
	ret	z
	jr	FindNextAvailCluster

;;;;;;;;;;;;

ChainClusters:
	;	Chain cluster HL to DE
	ld	bc, (fat_cluster)	; Back up current cluster
	push	bc
	push	de			; Back up dest. cluster
	call	SeekCluster		; Seek cluster HL
	pop	de			; Restore dest. cluster
	ld	hl, (fat_mem_index)	; Set HL to FAT buffer index
	ld	(hl), e			; Write DE (littleendian)
	inc	hl
	ld	(hl), d
	call	SaveFat			; Save  changes to disk
	pop	hl			; Get back to where we were
	call	SeekCluster
	ret

;;;;;;;;;;;;

TerminateChain:
	ld	hl, (fat_mem_index)	; Set HL to FAT buffer index
	ld	(hl), 0xF8		; Write 0xFFF8 (EOF)
	inc	hl
	ld	(hl), 0xFF
	call	SaveFat			; Save  changes to disk
	ret

;;;;;;;;;;;;

SeekCluster:
	; jump to cluster in HL
	ld	(fat_cluster), hl	; Keep target cluster
	ex	de,hl			; Now cluster is in DE
	ld	hl, (start_of_fat)
	ld	d, 0			; Set DE to 0D
	add	hl, de			; HL is now desired FAT sector
	ld	(fat_sector), hl

	ld	b, h			; Setup registers for CF_READ
	ld	c, l
	ld	de, 0
	ld	hl, fat_buffer
	ld	a, 1
	rst	0x20	; call CF_READ

	ld	hl, fat_buffer
	ld	de, (fat_cluster)
	ld	d, 0			; Set DE to 0E
	add	hl, de
	add	hl, de
	ld	(fat_mem_index), hl
	ld	a, e
	ld	(fat_index), a

	ld	hl, (fat_cluster)	; Don't clobber HL
	ret

;;;;;;;;;;;;

TestEOF:
	; Set Zero flag if current cluster value is 0xFFF8 - 0xFFFF
	; Clear Zero flag if not
	ld	hl, (fat_mem_index)	; Get pointer to current cluster
	ld	e, (hl)			; Read next cluster into DE
	inc	hl
	ld	d, (hl)
	ld	a, 0xFF
	cp	d
	ret	nz			; If D != 0xFF, this ain't EOF
	; We're EOF if E is 0xF8, 0xF9, 0xFA, ..., 0xFF.
	; In other words, if the first 5 bits of E are set
	; So let's set the last 3 bits to 1 and then test
	; against 0xFF
	ld	a, e
	or	00000111b
	cp	0xFF
	ret

;;;;;;;;;;;;

FollowClusterChain:
	; Sector we want is start_of_fat + high order byte of current cluster
	ld	hl, (fat_mem_index)	; Get pointer to current cluster
	ld	e, (hl)			; Read next cluster into DE
	inc	hl
	ld	d, (hl)
	ex	de, hl
	call	SeekCluster
	ret

;;;;;;;;;;;;

SaveFat:
	ld	hl, fat_buffer
	ld	bc, (fat_sector)
	ld	de, 0
	ld	a, 1
	call	CF_WRITE
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Root directory handling stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ResetRootDir:
	; Read first sector of root dir off disk
	ld	hl, root_dir_buffer
	ld	bc, (start_of_root_dir)
	ld	(root_dir_sector), bc
ResetRootDirAdvanceDirEntryPoint:
	ld	de, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ
	; Update indexes
	ld	a, 0
	ld	(root_dir_index), a
	ld	hl, root_dir_buffer
	ld	(root_dir_mem_index), hl
	; Copy first entry into dir_ent_buffer
	ld	de, dir_entry_buffer
	ld	bc, 32
	ldir
	ret

;;;;;;;;;;;;

AdvanceDirEnt:
	ld	a, (root_dir_index)
	inc	a
	cp	16	; 16 dir entries / sector
	jr	z, AdvanceDirEnt_ReadNewSector
	ld	(root_dir_index), a
	ld	hl, (root_dir_mem_index)
	ld	bc, 32
	add	hl, bc
	ld	(root_dir_mem_index), hl
	ld	de, dir_entry_buffer
	ldir
	ret
AdvanceDirEnt_ReadNewSector:
	ld	hl, root_dir_buffer
	ld	bc, (root_dir_sector)
	inc	bc
	ld	(root_dir_sector), bc
	jr	ResetRootDirAdvanceDirEntryPoint

;;;;;;;;;;;;

TestLFN:
	ld	a, (attribs)
	cp	0x0F
	ret

;;;;;;;;;;;;

TestEndDir:
	ld	a, (filename)
	cp	0x00
	ret

;;;;;;;;;;;;

TestFreeEntry:
	ld	a, (filename)
	cp	0xE5
	ret

;;;;;;;;;;;;

FindFirstAvailDirEnt:
	call	ResetRootDir
FindFirstAvailDirEntLoop:
	call	TestLFN
	jr	z, FindFirstAvailDirEntNext
	call	TestEndDir
	jr	z, FindFirstAvailDirEnt_DirEnd
	call	TestFreeEntry
	jr	z, FindFirstAvailDirEnt_Free
FindFirstAvailDirEntNext:
	call	AdvanceDirEnt
	jr	FindFirstAvailDirEntLoop
FindFirstAvailDirEnt_Free:
	ld	a, 0x00
	ret
FindFirstAvailDirEnt_DirEnd:
	ld	a, 0xFF
	ret

;;;;;;;;;;;;

MakeDirEndEntry:
	ld	a, 0x00
	ld	(filename), a
	ret

;;;;;;;;;;;;

MakeAvailEntry:
	ld	a, 0xE5
	ld	(filename), a
	ret

;;;;;;;;;;;;

ZeroFilename:
	ld	hl, filename
	ld	a," "
	ld	b, 11
ZeroFilenameLoop:
	ld	(hl), a
	inc	hl
	djnz	ZeroFilenameLoop
	ret

;;;;;;;;;;;;

BuildFilenameString:
	; This populates filename_buffer with a human friendly
	; version of the filename of the current dir entry.
	; i.e. it removes padding from the filename, puts a
	; period before extension and a slash after directories.
	ld	hl, filename
	ld	de, filename_buffer	; DE at filename, HL at dir entry
	ld	bc, 8			; Copy 8 chars to filename buffer
	ldir
	ex	de, hl			; Terminate this 8 char string
	ld	(hl), "\0"
	ld	hl, filename_buffer	; Remove trailing whitespace
	call	StrStrip
	ld	de, extension		; Check if there is a file extension
	ld	a, (de)
	cp	" "
	jr	z, BuildFilenameStringAddDirSlash
	ld	(hl), "."		; Write the file extension separator
	inc	hl
	ex	de, hl			; Now HL=extension, DE=filename_buffer
	ld	bc, 3			; Copy 3 chars (ext) to fname buffer
	ldir
	ex	de, hl			; Now HL=filename_buffer
BuildFilenameStringAddDirSlash:
	ld	a,(attribs)		; Get attribute byte
	and	00010000b;		; Mask out the directory bit
	jp	z, BuildFilenameEnd	; If not a dir, we're done
	ld	(hl), "/"		; If we're a dir, add a slash
	inc	hl
BuildFilenameEnd:
	ret

;;;;;;;;;;;;

ReverseBuildFilenameString:
	; This is the reverse of BuildFilenameString
	call	ZeroFilename
	;;;;; Copy filename
	ld	hl, filename
	ld	de, filename_buffer
	ld	b, 8
WriteNameLoop:
	ld	a, (de)
	inc	de
	; If we've hit the end of the string at this point,
	; there is no extension, so we're done with filename
	; wrangling.
	cp	0x00
	ret	z
	; If we've encountered a period, we're done with the
	; filename proper and need to handle the extension
	cp	"."
	jr	z, WriteExtension
	; Otherwise, we can add this char to the filename and
	; then see if we've hit the 8 char limit
	ld	(hl), a
	inc	hl
	djnz	WriteNameLoop
	; At this point we've copied 8 chars.  If we're now
	; pointing at a period, we need to jump over it and then
	; handle the extension
	ld	a, (de)
	cp	"."
	jr	z, SkipPeriod
	; If we're pointing at anything else here, truncate the
	; string and we're done.
	ret
SkipPeriod:
	inc	de
WriteExtension:
	ld	hl, extension
	ld	b, 3
WriteExtensionLoop:
	ld	a, (de)
	inc	de
	cp	0x00
	ret	z
	ld	(hl), a
	inc	hl
	djnz	WriteExtensionLoop


;;;;;;;;;;;;

UpdateRootDir:
	ld	hl, dir_entry_buffer
	ld	de, (root_dir_mem_index)
	ld	bc, 32
	ldir
	ret

;;;;;;;;;;;;

SaveRootDir:
	ld	hl, root_dir_buffer
	ld	bc, (root_dir_sector)
	ld	de, 0
	ld	a, 1
	call	CF_WRITE
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; File reading and writing stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReadFile:
	; Load the contents of the file corresponding to the current directory entry
	; into memory at the location pointed to by HL
	ld	(memory_pointer), hl
	ld	hl, (starting_cluster)
	call	SeekCluster
ReadFileLoop:
	; Convert current_cluster to sector in b,c,d,e
	ld	hl, (fat_cluster)
	call	ClusterToSector
	; Read one sector
	ld	hl, (memory_pointer)
	ld	a, 0x01
	rst	0x20	; call CF_READ
	ld	(memory_pointer), hl
	; Is there another cluster?
	call	TestEOF
	ret	z
	; Move to next cluster and loop
	call	FollowClusterChain
	jr	ReadFileLoop

;;;;;;;;;;;;

WriteFile:
	; Write BC bytes from memory, starting at HL, to disk.
	; Give filename pointed to by DE.

	; First, save params to memory
	ld	(memory_pointer), hl
	ld	(total_bytes), bc
	ld	(bytes_remaining), bc
	ld	(target_filename_ptr), de

	; Now, find an empty sector to start the chain
	; and remember it
	call	FindFirstAvailCluster
	ld	hl, (fat_cluster)
	ld	(new_file_start_clu), hl

	; Now write all the sectors in the chain
WriteFileWriteSector:
	;; Write a sector
	ld	hl, (fat_cluster)
	call	ClusterToSector
	ld	hl, (memory_pointer)
	ld	a, 1
	call	CF_WRITE
	;; Save memory pointer
	ld	(memory_pointer), hl
	;; Figure out if we're done or need another sector
	ld	hl, (bytes_remaining)
	ld	de, 512
	or	a ; Clear carry flag before sbc
	sbc	hl, de
	;; If that sbc went negative, we're done
	jr	c, WriteFileEndChain
	;; If not, we need to allocate another sector in the chain
	ld	(bytes_remaining), hl

	ld	hl, (fat_cluster)
	push	hl
	call	FindNextAvailCluster
	pop	hl
	ld	de, (fat_cluster)
	call	ChainClusters
	jr	WriteFileWriteSector
WriteFileEndChain:
	call	TerminateChain

	; Now add the corresponding directory entry
	call	ResetRootDir
	call	FindFirstAvailDirEnt
	push	af		; Store A, which tells us whether
				; or not we need to add a new
				; dir end marker

	;; Copy the provided filename into the buffer
	ld	hl, (target_filename_ptr)
	ld	de, filename_buffer
	ld	bc, 16
	ldir
	;; Now fill the dent with it
	call	ReverseBuildFilenameString


	;; Starting cluster
	ld	de, (new_file_start_clu)
	ld	hl, starting_cluster
	ld	(hl), e
	inc	hl
	ld	(hl), d
	;; Total size
	ld	de, (total_bytes)
	ld	hl, size_in_bytes
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), 0x00
	inc	hl
	ld	(hl), 0x00
	;; Attribs
	ld	a, 0
	ld	(attribs), a

	;; Write theupdated directory entry back to disk
	call	UpdateRootDir
	call	SaveRootDir
	pop	af		; Restore A, which flags whether
				; or not we need to write a dir end
	cp	0
	ret	z

	; If we're here, we need to add a new end-of-dir marker
	; dent, because we clobbered the old one.
	call	AdvanceDirEnt
	call	MakeDirEndEntry
	call	UpdateRootDir
	call	SaveRootDir
	ret

;;;;;;;;;;;;

FindFile:
	; Advance directory pointer to find file matching string
	; pointed to by HL
	ld	(target_filename_ptr), hl
	call	ResetRootDir		; Jump to start of root dir
FindFileLoop:
	call	TestEndDir
	jr	z, FindFileNotFound
	call	TestFreeEntry
	jr	z, FindFileNext
	call	TestLFN
	jr	z, FindFileNext
	; Compare names
	call	BuildFilenameString
	ld	(hl), "\0"		; BuildFilenameString doesn't terminate!
	ld	hl, filename_buffer
	ld	de, (target_filename_ptr)
	call	StrictStrCmp
	; If match, jump to end
	jr	z, FindFileFound
	; Otherwise check next entry
FindFileNext:
	call	AdvanceDirEnt
	jr	FindFileLoop
FindFileFound:
	; We found it, and the dir entry now points at it
	ld	a, 0	; Success
	cp	0
	ret
FindFileNotFound:
	; We did NOT find it! :(
	ld	a, 0xFF	; Fail!
	cp	0
	ret
