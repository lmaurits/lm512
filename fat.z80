InitFAT:
ReadMBR:
	; The MBR is the first sector of the disk.
	ld	hl, fat_sector_buffer
	ld	a, 01	; MBR is one sector
	ld	b, 00	; MBR starts at sector 0
	ld	c, 00
	ld	d, 00
	ld	e, 00
	rst	0x20	; call CF_READ
ReadVBR:
	; The MBR contains the address of the first sector of partition 1
	; Store this in memory for future reference, then read that sector
	; (the VBR) into memory.
	ld	ix, fat_sector_buffer+0x1BE
	ld	c, (ix+0x08)
	ld	a, c
	ld	(partition_start_sec+0), a
	ld	b, (ix+0x09)
	ld	a, b
	ld	(partition_start_sec+1), a
	ld	e, (ix+0x0A)
	ld	a, e
	ld	(partition_start_sec+2), a
	ld	d, (ix+0x0B)
	ld	a, d
	ld	(partition_start_sec+3), a
	ld	a, 01	; VBR is one sector
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
ReadBPB:
	; The VBR contains essential information on the FAT filesystem
	; Store all of this in memory for future reference
	ld	hl, fat_sector_buffer+0x0B
	ld	de, fat_spec_table
	ld	bc, 13
	ldir

ComputeSectors:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Assuming that the fat_spec_table is correctly populated, compute
; the address of the first sector of the root directory, and load
; it into the sector buffer.  Note that this function is currently
; LAZY, i.e. it makes assumptions about the FAT spec, e.g. that there
; are 2 FATs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Compute the starting sectors of various regions of the FAT
	ld	hl, (partition_start_sec)	; Start HL at partition start
	ld	bc, (reserved_sectors)
	add	hl, bc				; Skip past reserved sectors
	ld	(start_of_fat), hl
	ld	bc, (sectors_per_fat)
	add	hl, bc			; Skip past first FAT
	add	hl, bc			; Skip past second FAT
	ld	(start_of_root_dir), hl
	ld	bc, 32			; Skip past root directory - LAZY
	add	hl, bc
	ld	(start_of_data), hl
	; Dump some info for debugging

	ld	hl, InitFatDebugStr1
	call	PrintStringA
	ld	hl, dos_linebuf
	ld	de, (start_of_fat)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\r"
	inc		hl
	ld		(hl), "\n"
	inc		hl
	ld		(hl), "\0"
	inc		hl
	ld		hl, dos_linebuf
	call		PrintStringA

	ld	hl, InitFatDebugStr2
	call	PrintStringA
	ld	hl, dos_linebuf
	ld	de, (start_of_root_dir)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\r"
	inc		hl
	ld		(hl), "\n"
	inc		hl
	ld		(hl), "\0"
	inc		hl
	ld		hl, dos_linebuf
	call		PrintStringA

	ld	hl, InitFatDebugStr3
	call	PrintStringA
	ld	hl, dos_linebuf
	ld	de, (start_of_data)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\r"
	inc		hl
	ld		(hl), "\n"
	inc		hl
	ld		(hl), "\0"
	inc		hl
	ld		hl, dos_linebuf
	call		PrintStringA
	ret

InitFatDebugStr1:
	defm	"Start of FAT: \0"
InitFatDebugStr2:
	defm	"Start of root dir: \0"
InitFatDebugStr3:
	defm	"Start of data: \0"

ReadRootDir:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld	bc, (start_of_root_dir)
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
	ret


BuildFilenameString:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ld	hl, filename
	ld	de, filename_buffer	; DE at filename, HL at dir entry
	ld	bc, 8			; Copy 8 chars to filename buffer
	ldir
	ex	de, hl			; Terminate this 8 char string
	ld	(hl), "\0"
	ld	hl, filename_buffer	; Remove trailing whitespace
	call	StrStrip
	ld	de, extension		; Check if there is a file extension
	ld	a, (de)
	cp	" "
	jr	z, BuildFilenameStringAddDirSlash
	ld	(hl), "."		; Write the file extension separator
	inc	hl
	ex	de, hl			; Now HL=extension, DE=filename_buffer
	ld	bc, 3			; Copy 3 chars (ext) to fname buffer
	ldir
	ex	de, hl			; Now HL=filename_buffer
BuildFilenameStringAddDirSlash:
	ld	a,(attribs)		; Get attribute byte
	and	00010000b;		; Mask out the directory bit
	jp	z, BuildFilenameEnd	; If not a dir, we're done
	ld	(hl), "/"		; If we're a dir, add a slash
	inc	hl
BuildFilenameEnd:
	ret





WalkRootDir:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Walk the root directory, executing callbacks along the way
;
; * dir_walk_loop_callback is called for each file.  By writing a non-zero
;   value to dir_walk_breakout it can break out of the loop early.
; * dir_walk_break_callback will be called at an early loop breakout
; * dir_walk_end_callback will be called if the loop ends without being
;   broken out of, after fully traversing the directory.
;
; All callbacks should end with a ret as per usual.  This function maintains
; the stack such that this will return to wherever WalkRootDir was called from.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ld	a, 00
	ld	(dir_walk_breakout), a	; Clear breakout claf
	ld	hl, (start_of_root_dir)	; Set root_dir_sector to first sector
	ld	(root_dir_sector), hl	
WalkRootDirOuterLoop:
	; Read next sector of root dir into fat_sector_buffer
	ld	bc, (root_dir_sector)
	push	bc
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
	pop	bc
	inc	bc
	ld	(root_dir_sector), bc
	ld	b, 16	; Directory entries per sector
	push	bc
	ld	hl, fat_sector_buffer
WalkRootDirInnerLoop:
	; Read directory entry
	ld	de, dir_entry_buffer
	ld	bc, 32
	ldir
	push	hl
	; Check for end of dir
	ld	hl, filename
	ld	a, (hl)
	cp	0x00
	jr	z, WalkRootDirEnd
	; Check for free entry, and if so skip
	cp	0xE5
	jr	z, WalkRootDirNext
	; Check for LFN entry, and if so skip
	ld	a, (attribs)
	cp	0x0f
	jr	z, WalkRootDirNext
	; Execute callback
	ld	hl, (dir_walk_loop_callback)
	ld	de, WalkRootDirLoopReentry	; Manually push return address.
	push	de
	jp	(hl)
WalkRootDirLoopReentry:
	; Check if the callback asked us to break out of the loop
	ld	a, (dir_walk_breakout)
	cp	0
	jr	nz,WalkRootDirBreakout
WalkRootDirNext:
	; Continue looping
	pop	hl
	pop	bc
	dec	b
	jr	z, WalkRootDirOuterLoop
	push	bc
	jr	WalkRootDirInnerLoop
WalkRootDirBreakout:
	pop	hl
	pop	bc
	; Execute callback
	; Don't push a return address - the ret of the callback will return
	; to the caller of WalkRootDir, which is fine
	ld	hl, (dir_walk_break_callback)
	jp	(hl)
WalkRootDirEnd:
	pop	hl
	pop	bc
	; Execute callback
	; Don't push a return address - the ret of the callback will return
	; to the caller of WalkRootDir, which is fine
	ld	hl, (dir_walk_end_callback)
	jp	(hl)

;;;;;;;;;;;;

NullCallback:
	ret

;;;;;;;;;;;;

ClusterToSector:
	; Load b,c,d,e with the sector corresponding to the cluster in hl
	ld	bc, (start_of_data)
	add	hl, bc			; add 1 sector per cluster
	or	a			; Clear carry flag
	ld	bc, 2
	sbc	hl, bc			; Subtract 2 (clusters 0, 1 don't map to data region)
	ld	b, h
	ld	c, l
	ld	d, 0
	ld	e, 0
	ret

;;;;;;;;;;;;

AdvanceCluster:
	; Sector we want is start_of_fat + high order byte of current cluster
	ld	hl, (start_of_fat)
	ld	bc, (current_cluster)
	ld	c, b
	ld	b, 0
	add	hl, bc
	; Read that sector of the fat
	ld	b, h
	ld	c, l
	ld	d, 0
	ld	e, 0
	ld	hl, fat_sector_buffer
	ld	a, 1
	rst	0x20	; call CF_READ
	; Offset into the sector we want is the low order byte of curent cluster
	ld	hl, fat_sector_buffer
	ld	bc, (current_cluster)
	ld	b, 0
	add	hl, bc
	add	hl, bc
	; Read FAT entry into BC
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	ld	(current_cluster), bc
	; Check if we're done
	ld	hl, (current_cluster)
	ld	bc, 0xFFF8
	or	a			; Clear carry flag
	sbc	hl, bc
	ret

;;;;;;;;;;;;

ReadFile:
	; Load the contents of the file corresponding to the current directory entry
	; into memory at the location pointed to by HL
	ld	(memory_pointer), hl
	ld	hl, (starting_cluster)
	ld	(current_cluster), hl
ReadFileLoop:
	; Convert current_cluster to sector in b,c,d,e
	call	ClusterToSector
	; Read one sector
	ld	hl, (memory_pointer)
	ld	a, 0x01
	rst	0x20	; call CF_READ
	ld	(memory_pointer), hl
	; Get next cluster
	call	AdvanceCluster
	; Check to see if done
	jr	c, ReadFileLoop
	ret

;;;;;;;;;;;;

ResetFat:
	; Read first sector of FAT off disk
	ld	hl, fat_buffer
	ld	bc, (start_of_fat)
	ld	(fat_sector), bc
ResetFatAdvanceSectorEntryPoint:
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ
	; Skip over reserved clusters
	ld	hl, fat_buffer
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	; Update indexes
	ld	(fat_mem_index), hl
	ld	hl, 0x0002
	ld	(fat_cluster), hl
	ld	a, 2
	ld	(fat_index), a
	ret

;;;;;;;;;;;;

AdvanceCluster2:
	;; Increment cluster
	ld	hl, (fat_cluster)
	inc	hl
	ld	(fat_cluster), hl

	;; Increment index and figure out if we need to read new sec
	ld	a, (fat_index)
	inc	a
	cp	32	; 32 clusters / sector
	jr	z, AdvanceCluster_ReadNewSector
	ld	(fat_index), a

	;; Increment FAT memory index
	ld	hl, (fat_mem_index)
	inc	hl
	inc	hl
	ld	(fat_mem_index), hl

	ret
AdvanceCluster_ReadNewSector:
	;; Read new sector
	ld	hl, fat_buffer
	ld	bc, (fat_sector)
	inc	bc
	ld	(root_dir_sector), bc
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ

	;; Reset index and mem_index
	ld	a, 0
	ld	(fat_index), a
	ld	hl, fat_buffer
	ld	(fat_mem_index), hl
	ret

;;;;;;;;;;;;

FindFirstAvailCluster:
	call	ResetFat
FindFirstAvailCluster_1:
	ld	hl, (fat_mem_index)
	ld	a, (hl)
	inc	hl
	ld	b, (hl)
	or	b
	cp	0
	ret	z
	call	AdvanceCluster2
	jr	FindFirstAvailCluster_1

;;;;;;;;;;;;

SaveFat:
	ld	hl, fat_buffer
	ld	bc, (fat_sector)
	ld	d, 0
	ld	e, 0
	ld	a, 1
	call	CF_WRITE
	ret

;;;;;;;;;;;;

ResetRootDir:
	; Read first sector of root dir off disk
	ld	hl, root_dir_buffer
	ld	bc, (start_of_root_dir)
	ld	(root_dir_sector), bc
ResetRootDirAdvanceDirEntryPoint:
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	rst	0x20	; call CF_READ
	; Update indexes
	ld	a, 0
	ld	(root_dir_index), a
	ld	hl, root_dir_buffer
	ld	(root_dir_mem_index), hl
	; Copy first entry into dir_ent_buffer
	ld	de, dir_entry_buffer
	ld	bc, 32
	ldir
	ret

;;;;;;;;;;;;

AdvanceDirEnt:
	ld	a, (root_dir_index)
	inc	a
	cp	16	; 16 dir entries / sector
	jr	z, AdvanceDirEnt_ReadNewSector
	ld	(root_dir_index), a
	ld	hl, (root_dir_mem_index)
	ld	bc, 32
	add	hl, bc
	ld	(root_dir_mem_index), hl
	ld	de, dir_entry_buffer
	ldir
	ret
AdvanceDirEnt_ReadNewSector:
	ld	hl, root_dir_buffer
	ld	bc, (root_dir_sector)
	inc	bc
	ld	(root_dir_sector), bc
	jr	ResetRootDirAdvanceDirEntryPoint

;;;;;;;;;;;;

FindFirstAvailDirEnt:
	call	ResetRootDir
FindFirstAvailDirEnt_1:
	; Check for LFN entry, and if so skip
	ld	a, (attribs)
	cp	0x0F
	jr	z, FindFirstAvailDirEnt_2
	; Is this the end of the dir?
	ld	hl, filename
	ld	a, (hl)
	cp	0x00
	jr	z, FindFirstAvailDirEnt_DirEnd
	; Is this a free entry?
	cp	0xE5
	jr	z, FindFirstAvailDirEnt_Free
	; Otherwise advance and loop
FindFirstAvailDirEnt_2:
	call	AdvanceDirEnt
	jr	FindFirstAvailDirEnt_1
FindFirstAvailDirEnt_Free:
	ld	a, 0x00
	ret
FindFirstAvailDirEnt_DirEnd:
	ld	a, 0xFF
	ret

;;;;;;;;;;;;

MakeDirEndEntry:
	ld	a, 0x00
	ld	(filename), a

;;;;;;;;;;;;

ZeroFilename:
	ld	hl, filename
	ld	a," "
	ld	b, 11
ZeroFilenameLoop:
	ld	(hl), a
	inc	hl
	djnz	ZeroFilenameLoop
	ret

;;;;;;;;;;;;

UpdateRootDir:
	ld	hl, dir_entry_buffer
	ld	de, (root_dir_mem_index)
	ld	bc, 32
	ldir
	ret

;;;;;;;;;;;;

SaveRootDir:
	ld	hl, root_dir_buffer
	ld	bc, (root_dir_sector)
	ld	d, 0
	ld	e, 0
	ld	a, 1
	call	CF_WRITE
	ret

;;;;;;;;;;;;

WriteFileStr1:
	defm	"Looking for empty sector...\r\n\0"
WriteFileStr2:
	defm	": I think this is the first empty sector\r\n\0"
WriteFileStr3:
	defm	"Now searching for a blank spot in the root dir...\r\n\0"
WriteFileStr4:
	defm	"Hitting the disk now...\r\n\0"
WriteFile:
	; Write BC bytes from memory, starting at HL, to disk.
	; Give filename pointed to by DE.
	ld	(memory_pointer), hl
	ld	(total_bytes), bc
	ld	(bytes_remaining), bc
	ld	(target_filename_ptr), de

	; Find empty sector
	call	ResetFat
	call	FindFirstAvailCluster
	ld	hl, (fat_cluster)
	ld	(new_file_start_clu), hl
	; Mark this sector as end of chain
	ld	hl, (fat_mem_index)
	ld	a, 0xFF
	ld	(hl), a
	inc	hl
	ld	(hl), a
	call	SaveFat

	;; Now write a sector
	ld	hl, (fat_cluster)
	call	ClusterToSector
	ld	hl, (memory_pointer)
	ld	a, 1
	call	CF_WRITE
	;; Advance memory pointer
	ld	de, 512
	add	hl, de
	ld	(memory_pointer), hl
	ld	de, 512
	ld	hl, (bytes_remaining)
	or	a ; Clear carry flag before sbc
	sbc	hl, de
	jp	pe, WriteFileMakeDent
	ld	(bytes_remaining), hl

WriteFileMakeDent:
	call	ResetRootDir
	call	FindFirstAvailDirEnt
	push	af
	call	ZeroFilename
	;;;;; Copy filename
	ld	hl, filename
	ld	de, (target_filename_ptr)
	ld	b, 8
WriteNameLoop:
	ld	a, (de)
	inc	de
	cp	0x00
	jr	z, WriteStartingCluster
	cp	"."
	jr	z, WriteExtension
	ld	(hl), a
	inc	hl
	djnz	WriteNameLoop
WriteExtension:
	ld	hl, extension
	ld	b, 3
WriteExtensionLoop:
	ld	a, (de)
	inc	de
	cp	0x00
	jr	z, WriteStartingCluster
	ld	(hl), a
	inc	hl
	djnz	WriteExtensionLoop
WriteStartingCluster:
	ld	de, (new_file_start_clu)
	ld	hl, starting_cluster
	ld	(hl), e
	inc	hl
	ld	(hl), d
	ld	hl, size_in_bytes
	ld	(hl), 0x00
	inc	hl
	ld	(hl), 0x00
	inc	hl
	ld	de, (total_bytes)
	ld	(hl), e
	inc	hl
	ld	(hl), d
	ld	a, 0
	ld	(attribs), a
WriteDentToDisk:
	call	UpdateRootDir
	call	SaveRootDir
	pop	af
	cp	0
	ret	z
WriteHandleDirEnd:
	call	AdvanceDirEnt
	call	MakeDirEndEntry
	call	UpdateRootDir
	call	SaveRootDir
	ret
