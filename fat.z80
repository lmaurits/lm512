InitFAT:
ReadMBR:
	; The MBR is the first sector of the disk.
	ld	hl, fat_sector_buffer
	ld	a, 01	; MBR is one sector
	ld	b, 00	; MBR starts at sector 0
	ld	c, 00
	ld	d, 00
	ld	e, 00
	rst	0x20	; call CF_READ
ReadVBR:
	; The MBR contains the address of the first sector of partition 1
	; Store this in memory for future reference, then read that sector
	; (the VBR) into memory.
	ld	ix, fat_sector_buffer+0x1BE
	ld	c, (ix+0x08)
	ld	a, c
	ld	(partition_start_sec+0), a
	ld	b, (ix+0x09)
	ld	a, b
	ld	(partition_start_sec+1), a
	ld	e, (ix+0x0A)
	ld	a, e
	ld	(partition_start_sec+2), a
	ld	d, (ix+0x0B)
	ld	a, d
	ld	(partition_start_sec+3), a
	ld	a, 01	; VBR is one sector
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
ReadBPB:
	; The VBR contains essential information on the FAT filesystem
	; Store all of this in memory for future reference
	ld	hl, fat_sector_buffer+0x0B
	ld	de, fat_spec_table
	ld	bc, 13
	ldir
ComputeSectors:
	; Compute the starting sectors of various regions of the FAT
	ld	hl, (partition_start_sec)	; Start HL at partition start
	ld	bc, (reserved_sectors)
	add	hl, bc				; Skip past reserved sectors
	ld	(start_of_fat), hl
	ld	bc, (sectors_per_fat)
	add	hl, bc			; Skip past first FAT
	add	hl, bc			; Skip past second FAT
	ld	(start_of_root_dir), hl
	ld	bc, 32			; Skip past root directory - LAZY
	add	hl, bc
	ld	(start_of_data), hl
	ret

ReadRootDir:
	; Assuming that the fat_spec_table is correctly populated, compute
	; the address of the first sector of the root directory, and load
	; it into the sector buffer.  Note that this function is currently
	; LAZY, i.e. it makes assumptions about the FAT spec, e.g. that there
	; are 2 FATs.
	ld	bc, (start_of_root_dir)
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
	ret

BuildFilenameString:
	ld	hl, filename
	ld	de, filename_buffer	; DE at filename, HL at dir entry
	ld	bc, 8			; Copy 8 chars to filename buffer
	ldir
	ex	de, hl			; Terminate this 8 char string
	ld	(hl), "\0"
	ld	hl, filename_buffer	; Remove trailing whitespace
	call	StrStrip
	ld	de, extension		; Check if there is a file extension
	ld	a, (de)
	cp	" "
	jr	z, BuildFilenameStringAddDirSlash
	ld	(hl), "."		; Write the file extension separator
	inc	hl
	ex	de, hl			; Now HL=extension, DE=filename_buffer
	ld	bc, 3			; Copy 3 chars (ext) to fname buffer
	ldir
	ex	de, hl			; Now HL=filename_buffer
BuildFilenameStringAddDirSlash:
	ld	a,(attribs)		; Get attribute byte
	and	00010000b;		; Mask out the directory bit
	jp	z, BuildFilenameEnd	; If not a dir, we're done
	ld	(hl), "/"		; If we're a dir, add a slash
	inc	hl
BuildFilenameEnd:
	ret

WalkRootDir:
	; Walk the root directory, executing callbacks along the way
	ld	a, 00
	ld	(dir_walk_breakout), a	; Clear breakout claf
	ld	hl, (start_of_root_dir)	; Set root_dir_sector to first sector
	ld	(root_dir_sector), hl	
WalkRootDirOuterLoop:
	; Read next sector of root dir into fat_sector_buffer
	ld	bc, (root_dir_sector)
	push	bc
	ld	d, 0
	ld	e, 0
	ld	a, 0x01
	ld	hl, fat_sector_buffer
	rst	0x20	; call CF_READ
	pop	bc
	inc	bc
	ld	(root_dir_sector), bc
	ld	b, 16	; Directory entries per sector
	push	bc
	ld	hl, fat_sector_buffer
WalkRootDirInnerLoop:
	; Read directory entry
	ld	de, dir_entry_buffer
	ld	bc, 32
	ldir
	push	hl
	; Check for end of dir
	ld	hl, filename
	ld	a, (hl)
	cp	0x00
	jr	z, WalkRootDirEnd
	; Check for free entry, and if so skip
	cp	0xE5
	jr	z, WalkRootDirNext
	; Check for LFN entry, and if so skip
	ld	a, (attribs)
	cp	0x0f
	jr	z, WalkRootDirNext
	; Execute callback
	ld	hl, (dir_walk_loop_callback)
	ld	de, WalkRootDirLoopReentry	; Manually push return address.
	push	de
	jp	(hl)
WalkRootDirLoopReentry:
	; Check if the callback asked us to break out of the loop
	ld	a, (dir_walk_breakout)
	cp	0
	jr	nz,WalkRootDirBreakout
WalkRootDirNext:
	; Continue looping
	pop	hl
	pop	bc
	dec	b
	jr	z, WalkRootDirOuterLoop
	push	bc
	jr	WalkRootDirInnerLoop
WalkRootDirBreakout:
	pop	hl
	pop	bc
	; Execute callback
	; Don't push a return address - the ret of the callback will return
	; to the caller of WalkRootDir, which is fine
	ld	hl, (dir_walk_break_callback)
	jp	(hl)
WalkRootDirEnd:
	pop	hl
	pop	bc
	; Execute callback
	; Don't push a return address - the ret of the callback will return
	; to the caller of WalkRootDir, which is fine
	ld	hl, (dir_walk_end_callback)
	jp	(hl)

;;;;;;;;;;;;

ClusterToSector:
	; Load b,c,d,e with the sector corresponding to the cluster in hl
	ld	bc, (start_of_data)
	add	hl, bc			; add 1 sector per cluster
	or	a			; Clear carry flag
	ld	bc, 2
	sbc	hl, bc			; Subtract 2 (clusters 0, 1 don't map to data region)
	ld	b, h
	ld	c, l
	ld	d, 0
	ld	e, 0
	ret

;;;;;;;;;;;;

AdvanceCluster:
	; Sector we want is start_of_fat + high order byte of current cluster
	ld	hl, (start_of_fat)
	ld	bc, (current_cluster)
	ld	c, b
	ld	b, 0
	add	hl, bc
	; Read that sector of the fat
	ld	b, h
	ld	c, l
	ld	d, 0
	ld	e, 0
	ld	hl, fat_sector_buffer
	ld	a, 1
	rst	0x20	; call CF_READ
	; Offset into the sector we want is the low order byte of curent cluster
	ld	hl, fat_sector_buffer
	ld	bc, (current_cluster)
	ld	b, 0
	add	hl, bc
	add	hl, bc
	; Read FAT entry into BC
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	ld	(current_cluster), bc
	; Check if we're done
	ld	hl, (current_cluster)
	ld	bc, 0xFFF8
	or	a			; Clear carry flag
	sbc	hl, bc
	ret

;;;;;;;;;;;;

ReadFile:
	; Load the contents of the file corresponding to the current directory entry
	; into memory at the location pointed to by HL
	ld	(memory_pointer), hl
	ld	hl, (starting_cluster)
	ld	(current_cluster), hl
ReadFileLoop:
	; Convert current_cluster to sector in b,c,d,e
	call	ClusterToSector
	; Read one sector
	ld	hl, (memory_pointer)
	ld	a, 0x01
	rst	0x20	; call CF_READ
	ld	(memory_pointer), hl
	; Get next cluster
	call	AdvanceCluster
	; Check to see if done
	jr	c, ReadFileLoop
	ret

;;;;;;;;;;;;

ListRootDir:
	ld	hl, ListLoopCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, NullCallback
	ld	(dir_walk_break_callback), hl
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

ListLoopCallback:
	call	BuildFilenameString
	call	TerminateLine
	ld	hl, filename_buffer
	call	PrintStringA
	ret

;;;;;;;;;;;;

LoadFile:
	; HL points to a filename we want to load
	; Save it for later
	ld	(target_filename_ptr), hl
	ld	hl, LoadLoopCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, NullCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, ExecEndCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

LoadLoopCallback:
	call	BuildFilenameString
	ld	(hl), "\0"		; BuildFilenameString doesn't terminate!
	ld	hl, filename_buffer
	ld	de, (target_filename_ptr)
	call	StrictStrCmp
	ret	nz
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x8000
	call	ReadFile
	; Let the directory walker know we can break out of the loop
	ld	a, 0xFF
	ld	(dir_walk_breakout), a
	ret

;;;;;;;;;;;;

ExecuteFile:
	; HL points to a filename we want to execute
	; Save it for later
	ld	(target_filename_ptr), hl
	ld	hl, ExecLoopCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, NullCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, ExecEndCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

ExecLoopCallback:
	call	BuildFilenameString
	ld	(hl), "\0"		; BuildFilenameString doesn't terminate!
	ld	hl, filename_buffer
	ld	de, (target_filename_ptr)
	call	StrictStrCmp
	ret	nz
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x8000
	call	ReadFile
	; Execute the file
	call	0x8000
	; Let the directory walker know we can break out of the loop
	ld	a, 0xFF
	ld	(dir_walk_breakout), a
	ret

ExecEndCallback:
	ld	hl, ExecuteFileFailMsg
	call	PrintStringA
	ret
ExecuteFileFailMsg:
	defm	"Bad command or filename.\r\n\0"

;;;;;;;;;;

NullCallback:
	ret
