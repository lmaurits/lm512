.STAT:		equ CFBASE + 0x07	; Status (R)
.SRA:		equ DUARTBASE + 0x01	; Status Register A (R)
.RHRA:		equ DUARTBASE + 0x03	; Rx Holding Register A (R)

nullhandler:
	ei
	reti

diskhandler:
	push	af
	in		a, (.STAT)		; Read disk status
	pop	af
	ei
	reti

tickhandler:
	; Back up registers which we touch
	; The fewer the better!
	push	hl
	push	bc
	push	af
	; Check if UART buffering is on
	ld	a, (uart_buffering)
	cp	0xFF
	jr	nz, tickhandler_uptime
BufferConsumeLoop:
	; Check if the UART FIFO has any chars in it.
	in a, (.SRA)		; Read status reg
	and 00000001b		; Mask off receive ready
	xor 00000001b		; Compare receive ready to 1
	jr	nz, tickhandler_uptime
	; Do we have room in the buffer for those chars?
	ld	a, (uart_buffer_size)
	cp	16
	jr	z, tickhandler_uptime
	; Read a char from the UART FIFO
	in	a, (.RHRA)
	; Check for various special control characters
	; Jump to handle them if needed
	cp	0x03		; Ctrl C
	jr	z, StackHandleCtrlC
	cp	0x1A		; Ctrl Z
	jr	z, StackHandleCtrlZ
	; Copy UART char into buffer
	ld	hl, (uart_buffer_pointer)
	ld	(hl), a
	inc	hl
	ld	(uart_buffer_pointer), hl
	ld	hl, uart_buffer_size
	inc	(hl)
	jr	BufferConsumeLoop
StackHandleCtrlC:
	; This is a Ctrl-C, terminate current process!
	ld	hl, HandleCtrlC
	jr	StackHack
StackHandleCtrlZ:
	; This is a Ctrl-Z, suspend current process!
	ld	hl, HandleCtrlZ
StackHack:
	; Hack the return address
	pop	af
	pop	bc
	; At this point, the stack is pointing to our pushed
	; version of HL from when we entered tickhandler.
	; Below that in the stack is the return address into
	; the running program (if any).  Let's put the address
	; of the program exec/susp handler *above* that address,
	; then replace all the registers
	ex	(sp), hl
	push	hl
	push	bc
	push	af

tickhandler_uptime:
	;;;; Handle tick counter
	ld	hl, ticks
	inc	(hl)
	ld	a, (hl)
	cp	64
	jr	nz, tickhandler_alarm
	ld	(hl), 0

	; Update uptime seconds
	ld	hl, uptime
	ld	b, 8
UptimeLoop:
	inc	(hl)
	ld	a, (hl)
	cp	0
	jr	nz, tickhandler_alarm
	inc	hl
	djnz	UptimeLoop

tickhandler_alarm:
	ld	a, (alarm_flag)
	cp	0xFF
	jr	nz, tickhandler_end
	ld	a, (alarm_tick)
	ld	b, a
	ld	a, (ticks)
	cp	b
	jr	nz, tickhandler_end
	ld	a, (alarm_countdown)
	dec	a
	ld	(alarm_countdown), a
	cp	0
	jr	nz, tickhandler_end
	ld	a, 0x00
	ld	(alarm_flag), a

tickhandler_end:
	in	a, (109)	; Reset RTC int
	pop	af
	pop	bc
	pop	hl		; Restore AF and HL
	ei			; Enable interrupts
	reti
