.STAT:		equ CFBASE + 0x07	; Status (R)
.SRA:		equ DUARTBASE + 0x01	; Status Register A (R)
.RHRA:		equ DUARTBASE + 0x03	; Rx Holding Register A (R)

nullhandler:
	ei
	reti

diskhandler:
	push	af
	in		a, (.STAT)		; Read disk status
	pop	af
	ei
	reti

tickhandler:
	push	hl
	push	bc
	push	af		; Save AF and HL
	; Buffered UART stuff
	ld	a, (uart_buffering)
	cp	0xFF
	jr	nz, tickhandler_uptime
BufferConsumeLoop:
	; Anything to read?
	in a, (.SRA)		; Read status reg
	and 00000001b		; Mask off receive ready
	xor 00000001b		; Compare receive ready to 1
	jr	nz, tickhandler_uptime
	; Got room?
	ld	a, (uart_buffer_size)
	cp	16
	jr	z, tickhandler_uptime
	; Add to buffer
	in	a, (.RHRA)
	cp	0x03		; Ctrl C
	jr	nz, BufferConsumeStore
	; This is a Ctrl-C, kill current process!
	; Hack the return address
	pop	af
	pop	bc
	; At this point, the stack is pointing to our pushed
	; version of HL from when we entered tickhandler.
	; Below that in the stack is the return address into
	; the running program (if any).  Let's put the address
	; of the program suspension handler *above* that address,
	; then replace all the registers
	ld	hl, ExecSuspendAddress
	ex	(sp), hl
	push	hl
	push	bc
	push	af
	; Break out of buffer looop
	jr	tickhandler_uptime
BufferConsumeStore:
	ld	hl, (uart_buffer_pointer)
	ld	(hl), a
	inc	hl
	ld	(uart_buffer_pointer), hl
	ld	hl, uart_buffer_size
	inc	(hl)
	jr	BufferConsumeLoop

tickhandler_uptime:
	;;;; Handle tick counter
	ld	hl, ticks
	ld	b, 64
	call	inc_and_check_wrap
	jr	nz, tickhandler_alarm

	;;;; Handle uptime tracking
	ld	hl, uptime_secs
	ld	b, 60
	call	inc_and_check_wrap
	jr	nz, tickhandler_alarm

	ld	hl, uptime_mins
	ld	b, 60
	call	inc_and_check_wrap
	jr	nz, tickhandler_alarm

	ld	hl, uptime_hours
	ld	b, 24
	call	inc_and_check_wrap
	jr	nz, tickhandler_alarm

	ld	hl, (uptime_days)
	inc	hl
	ld	(uptime_days), hl

tickhandler_alarm:
	ld	a, (alarm_flag)
	cp	0xFF
	jr	nz, tickhandler_end
	ld	a, (alarm_tick)
	ld	b, a
	ld	a, (ticks)
	cp	b
	jr	nz, tickhandler_end
	ld	a, (alarm_countdown)
	dec	a
	ld	(alarm_countdown), a
	cp	0
	jr	nz, tickhandler_end
	ld	a, 0x00
	ld	(alarm_flag), a

tickhandler_end:
	in	a, (109)	; Reset RTC int
	pop	af
	pop	bc
	pop	hl		; Restore AF and HL
	ei			; Enable interrupts
	reti

inc_and_check_wrap:
	; HL - address
	; B  - wrapping value
	ld	a, (hl)
	inc	a
	cp	b
	push	af
	jr	nz, inc_and_check_wrap_store
	ld	a, 0
inc_and_check_wrap_store:
	ld	(hl), a
	pop	af		; Get back flags from the wrap comp
	ret
