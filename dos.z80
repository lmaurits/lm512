;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DISK OPERATING SYSTEM
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include 'fat.z80'

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DOS CORE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Dos:
DosInit:
	; INITIALISE EVERYTHING
	
	; Print welcome message
	ld hl, welcomestr
	call PrintStringA
	; Initialise system variables
	ld		hl, 0x8000
	ld		(execaddr), hl
	ld		hl, 0x8000
	ld		(fileaddr), hl
	; Initialise filesystem
	call		InitFAT
	; Check for AUTOEXEC.BAT
	call		DosAutoExec
	; Start processing commands
	jp DosLoop
	welcomestr: defm "Welcome to LM-512 microcomputer system.\n\r\0"

DosAutoExec:
	; CHECK FOR FILE NAMED AUTOEXEC.BAT
	; IF FOUND, EXECUTE AS BATCH FILE

	ld		hl, DosAutoExecStr
	ld		(target_filename_ptr), hl
	call		FindFile
	ret		nz
	; Dent *should* now be pointed at our target
	jp		BatchCallback
DosAutoExecStr:
	defm		"AUTOEXEC.BAT\0"

DosLoop:
	; INFINITE LOOP OF READING A COMMAND LINE,
	; PARSING IT AND DISPATCHING THE COMMAND

	ld		hl, dos_promptstr
	call		PrintStringA
	ld		hl, dos_linebuf
	call		ReadLineA
	jr		nz, DosLoop ; User stopped input using Ctrl-C
	ld		hl, dos_linebuf
	ld		a, (hl)
	cp		"\0"
	jr		z, DosLoop
	call		DosHandleLine
	jr		DosLoop
dos_promptstr:
	defm		"> \0"

DosHandleLine:
	; HANDLE A COMMAND LINE: CONVERT TO UPPERCASE,
	; PARSE/TOKENISE LINE AND DISPATCH

;FIXME - can I get rid of the ld hl, dos_linebuf (it's setup
;before the call above) and then reuse this in Batch?)
	ld		hl, dos_linebuf	
	call		ConvertToUpper
	ld		bc, dos_argc
	call		ParseLine
	ld		bc, dos_dispatch_table
	call		Dispatch
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND DISPATCH
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Command strings

batchstr:	defm "BATCH\0"
clsstr:		defm "CLS\0"
cpstr:		defm "CP\0"
datestr:	defm "DATE\0"
flashstr:	defm "FLASH\0"
lsstr:		defm "LS\0"
monstr:		defm "MONITOR\0"
mvstr:		defm "MV\0"
serloadstr:	defm "SERLOAD\0"
receivestr:	defm "RECEIVE\0"
resetstr:	defm "RESET\0"
rmstr:		defm "RM\0"
loadstr:	defm "LOAD\0"
setstr:		defm "SET\0"
showstr:	defm "SHOW\0"
sleepstr:	defm "SLEEP\0"
typestr:	defm "TYPE\0"
uptimestr:	defm "UPTIME\0"

; Table linking command strings to function entry points
dos_dispatch_table:
	defw batchstr, Batch
	defw clsstr, Cls
	defw cpstr, Cp
	defw datestr, Date
	defw flashstr, Flash
	defw lsstr, Ls
	defw helpstr, DosHelp
	defw monstr, EnterMonitor
	defw mvstr, Mv
	defw serloadstr, SerialLoad
	defw showstr, Show
	defw sleepstr, SleepDos
	defw setstr, Set
	defw typestr, Type
	defw uptimestr, Uptime
	defw receivestr, Receive
	defw resetstr, Reset
	defw rmstr, Rm
	defw loadstr, DosLoadFile
	defw nullstr, ExecFile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DOS COMMANDS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Batch:
	; Load a file's contents into RAM and
	; execute it line-by-line as if it were
	; input to the shell

	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, BatchValidate
	;; Argc error
	ld		de, batchstr
OneFilenameArgcError:
	ld		hl, message_buffer
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, FilenameStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
BatchValidate:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz

	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
BatchCallback:
	; At this point, we've matched
	; Read the file into memory
	ld		hl, (fileaddr)
	call		ReadFile
	ld		hl, (fileaddr)
	ld		(line_start), hl
	ld		bc, (size_in_bytes)
BatchLoop:
	ld		a, 0x0A		; Newline
	cpir
	ld		(line_end), hl
	push		bc
	; Overwrite newline with string terminator
	dec		hl
	ld		(hl), "\0"
	ld		hl, (line_start)
	call		ConvertToUpper
	ld		bc, dos_argc
	call		ParseLine
	ld		bc, dos_dispatch_table
	call		Dispatch
	ld		hl, (line_end)
	ld		(line_start), hl
	pop		bc
	ld		a, b
	or		c
	ret		z
	jr		BatchLoop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Date:
	ld		a, (dos_argc)
	cp		0
	jp		z, DateGet
	cp		1
	jr		z, DateSet
	ld		hl, DateArgcErrStr
	call		PrintStringA
	ret
DateArgcErrStr:
	defm		"Date expects zero (to get) or one arguments (to set, YYMMDDHHmmSS)\r\n\0"
DateSet:
	ld		hl, (dos_argv)
	call		ValidateDateString
	ret		nz
	call		SetTimeFromString
ValidateDateString:
	call		StrLen
	cp		12
	jr		nz, ValidateDateStringErr
	call		IsStrDec
	jr		nz, ValidateDateStringErr
ValidateDateStringOkay:
	cp		a	; Set zero flag
	ret
ValidateDateStringErr:
	ld		hl, ValidateDateStringErrStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
ValidateDateStringErrStr:
	defm		"Set date with YYMMDDHHmmSS format\r\n\0"
SetTimeFromString:
	call		ReadBCDByte
	res		7, a			; Strip 7th bit
	push		af
	call		ReadBCDByte
	res		7, a
	push		af
	call		ReadBCDByte
	res		7, a
	ld		e, a
	call		ReadBCDByte
	res		7, a
	ld		d, a
	call		ReadBCDByte
	res		7, a
	ld		c, a
	call		ReadBCDByte
	res		7, a
	ld		b, a
	pop		af
	ld		h, a
	pop		af
	ld		l, a
	call		RTC_WRITE
	ret
DateGet:
	ld hl, 		message_buffer
	call		BuildTimeStr
	ld hl,		message_buffer
	call 		PrintStringA
	ret
BuildTimeStr:
	push		hl		; Save string pointer
	call		RTC_READ
	ex		de, hl		; Move year and month to DE
	pop		hl		; Restore string pointer

	; Year
	ld		(hl), "2"
	inc hl
	ld		(hl), "0"
	inc hl
	ld		a, e
	call WriteComponent
	ld		(hl), " "
	inc hl
	ld		a, d
	; Turn month into non-BCD
	ld		b, a
	; Mask off 10 digits in A
	and		00001111b
	srl 		b	; Shift down 10 digi
	srl		b
	srl		b
	srl		b
TimeStrLoop:
	add		10
	djnz		TimeStrLoop
	; Now deduct 1 (so Jan is offset 0)
	sub		1
	; Now multiply A by 3 (length of a month str)
	ld		b, a
	add		b
	add		b
	; Now use this as an index into month strings
	ld		b, 0
	ld		c, a
	ex		de, hl
	ld		hl, MonthStrings
	add		hl, bc
	ld		bc, 3
	ldir
	ex		de, hl
	ld (hl), " "
	inc hl
	; Day

	push		hl		; Save string pointer
	call		RTC_READ
	pop		hl		; Restore string pointer
	push		bc
	ld		a, e
	call WriteComponent
	ld (hl), " "
	inc hl

	ld		a, d
	call WriteComponent
	ld (hl), ":"
	inc hl
	ld		a, c
	call WriteComponent
	ld (hl), ":"
	inc hl
	pop 		bc
	ld		a, b
	call WriteComponent
	call TerminateLine
	ret

WriteComponent:
	ld b, a			; Copy
	srl a			; Shift down 10 digi
	srl a
	srl a
	srl a
	and 00000111b		; Mask off AM/PM
	add a, 48			; Convert to  ASCII
	ld (hl), a
	inc hl
	ld a, b
	and 00001111b
	add a, 48	; ASCII
	ld (hl), a
	inc hl
	ret

MonthStrings:
	defm	"JanFebMarAprMayJunJulAugSepOctNovDec"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Flash:
	ld		a, (dos_argc)
	cp		1
	jr		z, FlashValidate
	;; Argc error
	ld		de, flashstr
	call		OneFilenameArgcError
	ret
FlashValidate:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	; HL points to a filename we want to load
	; Save it for later
	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
	;; First, warn the user
	ld		hl, FlashNotice
	call		PrintStringA
	;; Now copy the core of this function into RAM
	;; where it will not get clobbered
	ld		hl, FlashRelocatablePayload
	ld		de, 0x8000	; Ignore FILEADDR, this is terminal!
	ld		bc, FlashRelocatablePayloadEnd - FlashRelocatablePayload	; Size of payload
	ldir			; Relocate
	jp		0x8000		; Do it!
FlashNotice:
defm	"Rewriting firmware.  Good luck!\r\n\0"

FlashRelocatablePayload:
	; NB: This is loaded into RAM at address 0x9000
	; But the assembler doesn't know this
	; So ONLY use jr, not jp, below
	ld		hl, 0x9000
	ld		(fileaddr), hl
	call		DosLoadFile	; Get new file in mem
	; Set BC to byte count
	ld		bc, (size_in_bytes)
	; Set HL to location of new file
	ld		hl, 0x9000
	; Set DE to destination
	ld		de, $0000	; DEST in ROM is $0000
	; Disable interrupts!
	di
FlashLoop:
	ld		b, (hl)		; Get the new byte in B
	ld		a, (de)		; Get the current byte in A
	cp		b		; Compare 'em
	jr		z, delay_loop_end; Don't overwrite needlessly
	ld		a, b
	ld		(de), a
	;;; Hacky delay loop
	exx
	ld		de, $071C
delay_loop:
	nop
	dec		de
	ld		a, d
	or		e
	jr		nz, delay_loop
	exx
delay_loop_end:
	;;; Back to copying...
	inc		hl
	inc		de
	dec		bc
	ld		a, b
	or		c
	jr		nz, FlashLoop
	; Reset when done
	jp 		$0000
FlashRelocatablePayloadEnd:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Ls:
	ld	hl,0x0000
	ld	(file_count), hl
	ld	(total_size), hl
	ld	(total_size+2), hl

	call	ResetRootDir		; Jump to start of root dir
LsLoop:
	call	TestEndDir
	jr	z, LsEnd
	call	TestFreeEntry
	jr	z, LsNext
	call	TestLFN
	jr	z, LsNext
	call	LsHandleFile
LsNext:
	call	AdvanceDirEnt
	jr	LsLoop
LsEnd:
	ld	hl, TotalStr
	call	PrintStringA
	ld	hl, (file_count)
	call	B2D16
	ld	hl, B2DBUF
	call	PrintStringA
	ld	hl, FilesStr
	call	PrintStringA

	ld	hl, BytesLeadStr
	call	PrintStringA
	ld	hl, (total_size)
	ld	de, (total_size+2)
	call	B2D32
	ld	hl, B2DBUF
	call	PrintStringA
	ld	hl, BytesStr
	call	PrintStringA
	ret

LsHandleFile:
	ld	hl, (file_count)
	inc	hl
	ld	(file_count), hl
	ld	hl, (total_size)
	ld	de, (size_in_bytes)
	add	hl, de
	ld	(total_size), hl
	ld	hl, (total_size+2)
	ld	de, 0
	adc	hl, de
	ld	(total_size+2), hl
	ld	hl, filename_buffer
	ld	a, " "
	ld	b, 12
LsBlankingLoop:
	ld	(hl), a
	inc	hl
	djnz	LsBlankingLoop
	call	BuildFilenameString
	ld	hl, filename_buffer
	ld	de, message_buffer
	ld	bc, 12
	ldir
	; Ugly, ugly clean up
	ld	de, message_buffer
	ld	b, 12
LsCleanLoop:
	ld	a, (de)
	cp	"\0"
	jr	z, LsCleanFix
	inc	de
	djnz	LsCleanLoop
	jr	LsUgh
LsCleanFix:
	ld	a, " "
	ld	(de), a
	jr	LsCleanLoop
LsUgh:
	push	de
	ld	hl, (size_in_bytes)
	ld	de, (size_in_bytes+2)
	call	B2D32
	pop	hl
	ld	a, 24
	sub	c
	push	bc
	ld	b, a
LsSpaceLoop:
	ld	(hl), " "
	inc	hl
	djnz	LsSpaceLoop
	pop	bc
	call	AppendB2D
	ld	(hl), "\0"
	ld	hl, message_buffer
	call	PrintStringA
	ld	hl, BytesStr
	call	PrintStringA
	ret
TotalStr:
	defm	"\nTotal:\t\t\t\0"
FilesStr:
	defm	" files\r\n\0"
BytesLeadStr:
	defm	"\t\t\t\0"
BytesStr:
	defm	" bytes\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DosHelp:
	ld hl, dos_helpmessage
	call PrintStringA
	ret
	dos_helpmessage:	defm "LM-512 DOS commands:\n\r"
	defm "BATCH\t\tExecute commands from text file\n\r"
	defm "CLS\t\tClear screen\n\r"
	defm "CP\t\tCopy file\n\r"
	defm "DATE\t\tPrint/set date and time\n\r"
	defm "FLASH\t\tFlash ROM from file\n\r"
	defm "LS\t\tList directory contents\n\r"
	defm "MONITOR\tEnter resident monitore\n\r"
	defm "MV\t\tMove (rename) file\n\r"
	defm "RECEIVE\tRead data from COM2 and save to file\n\r"
	defm "RESET\t\tReset system\n\r"
	defm "RM\t\tremove file\n\r"
	defm "SERLOAD\tRead data from COM2 to memory\n\r"
	defm "SET\t\tSet system var\n\r"
	defm "SHOW\t\tShow system var values\n\r"
	defm "SLEEP\t\tSleep for some seconds\n\r"
	defm "TYPE\t\tShow file contents\n\r"
	defm "UPTIME\t\tShow time since boot\n\r"
	defm "\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EnterMonitor:
	call		Monitor
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

proto_hello: equ $00
proto_hello_ack: equ $0F
proto_bytes: equ $F0
proto_send:  equ $FF

SerialLoad:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, SerialLoad00
	;; Prepare and pring arg error
	ld		hl, message_buffer
	ld		de, serloadstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, AddressStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
ExpectsExactlyOneArgStr:
	defm		" expects exactly one arg \0"
AddressStr:
	defm		"(mem address)\r\n\0"
SerialLoad00:
	; Validate address
	ld		hl, (dos_argv)
	call		ValidateAddress
	ret		nz
	; Parse address and store in HL
	call		Read16bit
	ld		h, b
	ld		l, c
SerialLoadCore:
	; Track how many bytes we receive
	ld		de, 0x0000
	; Reset server
	ld		a, proto_hello
	call		SERIAL_WRITE_B
	call		SERIAL_READ_B
	cp		proto_hello_ack
	jp		z, SerialLoad01
SerialLoad01:
transfer_outer_loop:
	ld		a, proto_bytes
	call		SERIAL_WRITE_B
	call		SERIAL_READ_B
	; A now contains byte count.  Turn to 16 bit in BC
	ld		b, 0
	ld		c, a
	; Increment byte received count
	ex		de, hl
	add		hl, bc
	ex		de, hl
	; Make sure we wren't just told there are no more bytes
	cp		0
	jp		z, SerialLoadEnd
	ld		a, proto_send
	call		SERIAL_WRITE_B
transfer_inner_loop:
	call		SERIAL_READ_B
	ld		(hl), a
	inc		hl
	dec		c
	ld		a, c
	cp		0
	jr		nz, transfer_inner_loop
	ld		a, "."
	call		SERIAL_WRITE_A
	jr		transfer_outer_loop
SerialLoadEnd:
	ld		hl, message_buffer
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\0"
	ld		hl, message_buffer
	call		PrintStringA
	ld		hl, SerialLoadStr
	call		PrintStringA
	ret
SerialLoadStr:
	defm		" bytes transferred.\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; SET
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This could be made smaller by sharing code with cli/Dispatch
Set:
	ld		a, (dos_argc)
	cp		2
	jr		z, SetValidate
	;; Argc error
	ld		hl, message_buffer
	ld		de, setstr
	call		StrCpy
	ld		de, ExpectsExactlyTwoArgsStr
	call		StrCpy
	ld		de, SetArgsStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
SetValidate:
	ld		hl, (dos_argv)
	ld		bc, SetTable
	call		MapString2Address
	; Now HL is either a RAM address or 0x0000
	ld		a, l
	cp		0
	jr		nz, SetDoIt
	ld		a, h
	cp		0
	jr		nz, SetDoIt
	; At this point we know the address is 0000, i.e. we did
	; not really match
SetError:
	ld		hl, SetBadVarStr
	call		PrintStringA
	ret
SetDoIt:
	push		hl	; The address
	ld		hl, (dos_argv+2)
	call		Read16bit
	pop		hl
	ld		(hl), c
	inc		hl
	ld		(hl), b
	ret

ExpectsExactlyTwoArgsStr:
	defm		" expects exactly two args \0"
SetArgsStr:
	defm		"(one variable name, one value).\r\n\0"
SetBadVarStr:
	defm		"Unrecognised variable.  Run SHOW to see all vars.\r\n\0"

execaddrstr:
	defm		"EXECADDR\0"
fileaddrstr:
	defm		"FILEADDR\0"

SetTable:
	defw execaddrstr, execaddr
	defw fileaddrstr, fileaddr
	defw nullstr, 0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; SHOW
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Show:
	ld		de, SetTable
ShowLoop:
	ex		de, hl
	ld		e, (hl)
	inc		hl
	ld		d, (hl)
	inc		hl
	ex		de, hl
	call		StrLen
	cp		0
	ret		z
	call		PrintStringA
	ld		hl, SeparatorStr
	call		PrintStringA
	ex		de, hl
	ld		c, (hl)
	inc		hl
	ld		b, (hl)
	inc		hl
	ex		de, hl
	ld		hl, message_buffer
	inc		bc
	ld		a, (bc)
	push		bc
	call		StrfHex
	pop		bc
	dec		bc
	ld		a, (bc)
	call		StrfHex
	call		TerminateLine
	ld		hl, message_buffer
	call		PrintStringA
	jr		ShowLoop
SeparatorStr:
	defm		":\t\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RECEIVE FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Receive:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, ReceiveValidate
	;; Argc error
	ld		de, receivestr
	jp		OneFilenameArgcError
FilenameStr:
	defm		"(8.3 filename(s))\r\n\0"
ReceiveValidate:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	;; First download the file
	ld		hl, (fileaddr)
	call		SerialLoadCore
	;; Now save
	ld		hl, (fileaddr)
	push		de
	pop		bc
	ld		de, (dos_argv)
	call		WriteFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RESET
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Reset:
	jp		0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RENAME FILE (MV)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Mv:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		2
	jr		z, Mv00
	;; Argc error
	ld		de, mvstr
TwoFilenamesArgcError:
	ld		hl, message_buffer
	call		StrCpy
	ld		de, ExpectsExactlyTwoArgsStr
	call		StrCpy
	ld		de, FilenameStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
Mv00:
ValidateTwoFilenames:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	ld		hl, (dos_argv+2)
	call		ValidateFilename
	ret		nz
	; HL points to a filename we want to rename
	ld		hl, (dos_argv)
	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
	; Dent *should* now be pointed at our target
	; Copy the new name into the filename buffer
	ld	hl, (dos_argv+2)
	ld	de, filename_buffer
	ld	bc, 12
	ldir
	; Overwrite the filename in the dent buffer
	call	ReverseBuildFilenameString
	; Save new dent to disk
	call	UpdateRootDir
	call	SaveRootDir
	ret

BadFileCallback:
	ld	hl, BadFileMsg
	call	PrintStringA
	ret
BadFileMsg:
	defm	"Bad command or filename.\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REMOVE FILE (RM)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Rm:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, RmValidate
	;; Argc error
	ld		de, rmstr
	jp		OneFilenameArgcError
RmValidate:
	ld		hl, (dos_argv)
	ld		(target_filename_ptr), hl
	call		ValidateFilename
	ret		nz

	; HL points to a filename we want to remove
	ld	hl, (dos_argv)
	ld		(target_filename_ptr), hl
	call	FindFile
	jp	nz, BadFileCallback
	; Dent *should* now be pointed at our target
	; First, remove the directory entry
	call	MakeAvailEntry
	call	UpdateRootDir
	call	SaveRootDir
	; Now free up the blocks in the FAT
	ld	hl, (starting_cluster)
	call	SeekCluster
RmLoop:
	call	TestEOF
	push	af			; Preserve results of EOF test
	ld	hl, (fat_mem_index)	; Get pointer to current cluster
	ld	e, (hl)			; Read next cluster into DE
	inc	hl
	ld	d, (hl)
	push	de
	;; Mark this cluster free
	ld	hl, (fat_mem_index)
	ld	a, 0x00
	ld	(hl), a
	inc	hl
	ld	(hl), a
	call	SaveFat
	;; Get next cluster back in HL
	pop	hl
	pop	AF			; Restore results of EOF test
	ret	z			; If this was the last cluster, return
	call	SeekCluster		; Otherwise, jump to the next
	jr	nz,RmLoop
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CLEAR SCREEN (CLS)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Cls:
	ld	hl, clsstring
	call	PrintStringA
	ret
clsstring:
	defb	0x1b
	defm	"[2J"
	defb	0x1b
	defm	"[H\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COPY FILE (CP)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Cp:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		2
	jr		z, Cp00
	;; Argc error
	ld		de, cpstr
	jp		TwoFilenamesArgcError
Cp00:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	ld		hl, (dos_argv+2)
	call		ValidateFilename
	ret		nz
	ld	hl, (dos_argv)
	call	LoadFile
	ld	hl, (fileaddr)
	ld	de, (dos_argv+2)
	ld	bc, (size_in_bytes)
	call	WriteFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; LOAD FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DosLoadFile:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, LoadValidate
	;; Argc error
	ld		de, loadstr
	jp		OneFilenameArgcError
LoadValidate:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
LoadFile:
	; HL points to a filename we want to remove
	ld		hl, (dos_argv)
	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
	; Dent *should* now be pointed at our target
	; Read the file into memory
	ld	hl, (fileaddr)
	call	ReadFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; EXEC FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ExecFile:
	ld		hl, dos_linebuf
	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
	; At this point, we've matched
	; Read the file into memory
	ld	hl, (execaddr)
	call	ReadFile
	; Can't actually call hl or (hl), so do this manually
	; with a push and jump
	ld	hl, ExecReturnAddress
	push	hl
	ld	hl, (execaddr)
	jp	(hl)
ExecReturnAddress:
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TYPE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Type:
	ld		a, (dos_argc)
	cp		1
	jr		z, TypeValidate
	;; Argc error
	ld		de, typestr
	jp		OneFilenameArgcError
TypeValidate:
	ld	hl, (dos_argv)
	ld	(target_filename_ptr), hl
	call		ValidateFilename
	ret		nz
	; HL points to a filename we want to load
	; Save it for later
	ld		hl, (dos_argv)
	ld		(target_filename_ptr), hl
	call		FindFile
	jp		nz, BadFileCallback
	; Dent *should* now be pointed at our target
	ld	hl, (fileaddr)
	call	ReadFile
	ld	hl, (fileaddr)
	ld	de, (size_in_bytes)
TypeLoop:
	ld	a, (hl)
	cp	0x0A	; newline
	jr	z, TypeNewline
	call	SERIAL_WRITE_A
TypeIncrement:
	inc	hl
	dec	de
	ld	a, d
	or	e
	jr	nz, TypeLoop
	ret
TypeNewline:
	ld	a, "\r"
	call	SERIAL_WRITE_A
	ld	a, "\n"
	call	SERIAL_WRITE_A
	jr	TypeIncrement

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TIMING STUFF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SleepDos:
	ld		a, (dos_argc)
	cp		1
	jr		z, SleepDos00
	;; Argc error
	ld		hl, message_buffer
	ld		de, sleepstr
	call		StrCpy
	ld		de, ExpectsExactlyOneArgStr
	call		StrCpy
	ld		de, SleepArgsStr
	call		StrCpy
	ld		hl, message_buffer
	call		PrintStringA
	ret
SleepArgsStr:
	defm		"(2 digit hex second count)\r\n\0"
SleepDos00:
	; Validate address
	ld		hl, (dos_argv)
	call		ValidateValue
	ret		nz
	; Parse address and store in HL
	call		Read8bit
	call		Sleep
	ret

Uptime:
	ld		hl, up_string
	call		PrintStringA
	ld		hl, (uptime_days)
	call		B2D16
	ld		hl, message_buffer
	call		AppendB2D
	ld		(hl), "\0"
	ld		hl, message_buffer
	call		PrintStringA
	ld		hl, days_string
	call		PrintStringA
	ld		a, (uptime_hours)
	call		B2D8
	call		PadTime
	ld		hl, message_buffer
	call		AppendB2D
	ld		(hl), ":"
	inc		hl
	push		hl
	ld		a, (uptime_mins)
	call		B2D8
	call		PadTime
	pop		hl
	call		AppendB2D
	ld		(hl), ":"
	inc		hl
	push		hl
	ld		a, (uptime_secs)
	call		B2D8
	call		PadTime
	pop		hl
	call		AppendB2D
	call		TerminateLine
	ld		hl, message_buffer
	call		PrintStringA
	ret
up_string:
	defm		"Up \0"
days_string:
	defm		" days, \0"

PadTime:
	ld		a, c
	cp		2
	ret		z
	dec		hl
	ld		(hl), "0"
	inc		c
	ret
