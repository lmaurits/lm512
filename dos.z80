;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DISK OPERATING SYSTEM
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include 'fat.z80'

Dos:
	
	; Print welcome message
	ld hl, welcomestr
	call PrintStringA
	; Initialise filesystem
	call		InitFAT
	; Check for AUTOEXEC.BAT
	call		DosAutoExec
	; Start processing commands
	jp DosLoop
	welcomestr: defm "Welcome to LM-512 microcomputer system.\n\r\0"

DosAutoExec:
	ld	hl, DosAutoExecStr
	ld	(target_filename_ptr), hl
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, BatchCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, NullCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret
DosAutoExecStr:
	defm		"AUTOEXEC.BAT\0"

DosLoop:
; Infinite loop of read, parse, dispatch
	ld		hl, dos_promptstr
	call		PrintStringA
	ld		hl, dos_linebuf
	call		ReadLineA
	jr		nz, DosLoop ; User stopped input using Ctrl-C
	ld		hl, dos_linebuf
	ld		a, (hl)
	cp		"\0"
	jr		z, DosLoop
	call		DosHandleLine
	jr		DosLoop
dos_promptstr:
	defm		"> \0"

DosHandleLine:
	ld		hl, dos_linebuf	
	call		ConvertToUpper
	ld		bc, dos_argc
	call		ParseLine
	ld		bc, dos_dispatch_table
	call		Dispatch
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND DISPATCH
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Command strings

batchstr:	defm "BATCH\0"
cpstr:		defm "CP\0"
datestr:	defm "DATE\0"
lsstr:		defm "LS\0"
monstr:		defm "MONITOR\0"
mvstr:		defm "MV\0"
serloadstr:	defm "SERLOAD\0"
receivestr:	defm "RECEIVE\0"
resetstr:	defm "RESET\0"
rmstr:		defm "RM\0"
loadstr:	defm "LOAD\0"
sleepstr:	defm "SLEEP\0"
typestr:	defm "TYPE\0"
uptimestr:	defm "UPTIME\0"

; Table linking command strings to function entry points
dos_dispatch_table:
	defw batchstr, Batch
	defw cpstr, Cp
	defw datestr, Date
	defw lsstr, Ls
	defw helpstr, DosHelp
	defw monstr, EnterMonitor
	defw mvstr, Mv
	defw serloadstr, SerialLoad
	defw sleepstr, SleepDos
	defw typestr, Type
	defw uptimestr, Uptime
	defw receivestr, Receive
	defw resetstr, Reset
	defw rmstr, Rm
	defw loadstr, DosLoadFile
	defw nullstr, ExecFile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DOS COMMANDS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Batch:
	; Load a file's contents into RAM and
	; execute it line-by-line as if it were
	; input to the shell

	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, BatchValidate
	ld		hl, BatchArgcErrorStr
	call		PrintStringA
	ret
BatchArgcErrorStr:
	defm		"BATCH expects exactly one arg (filename)\r\n\0"
BatchValidate:
	ld	hl, (dos_argv)
	ld	(target_filename_ptr), hl
	call		ValidateFilename
	ret		nz

	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, BatchCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

BatchCallback:
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x7000
	call	ReadFile
	ld	hl, 0x7000
	ld	(line_start), hl
	ld	bc, (size_in_bytes)
BatchLoop:
	ld	a, 0x0A		; Newline
	cpir
	ld	(line_end), hl
	push	bc
	; Overwrite newline with string terminator
	dec	hl
	ld	(hl), "\0"
	ld	hl, (line_start)
	call		ConvertToUpper
	ld		bc, dos_argc
	call		ParseLine
	ld		bc, dos_dispatch_table
	call		Dispatch
	ld	hl, (line_end)
	ld	(line_start), hl
	pop	bc
	ld	a, b
	cp	0
	jr	nz, BatchLoop
	ld	a, C
	cp	0
	jr	nz, BatchLoop
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Date:
	ld		a, (dos_argc)
	cp		0
	jr		z, DateGet
	cp		1
	jr		z, DateSet
	ld		hl, DateArgcErrStr
	call		PrintStringA
	ret
DateArgcErrStr:
	defm		"Date expects zero arguments (to get) or one argument (to set, YYMMDDHHmmSS)\r\n\0"
DateSet:
	ld		hl, (dos_argv)
	call		ValidateDateString
	ret		nz
	call		SetTimeFromString
DateGet:
	ld hl, dos_linebuf
	call BuildTimeStr
	ld hl, dos_linebuf
	call PrintStringA
	ret
ValidateDateString:
	call		StrLen
	cp		12
	jr		nz, ValidateDateStringErr
	call		IsStrDec
	jr		nz, ValidateDateStringErr
ValidateDateStringOkay:
	cp		a	; Set zero flag
	ret
ValidateDateStringErr:
	ld		hl, ValidateDateStringErrStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
ValidateDateStringErrStr:
	defm		"Date setting requires a 12 digit decimal string in YYMMDDHHmmSS format\r\n\0"
SetTimeFromString:
	call		ReadBCDByte
	res		7, a			; Strip 7th bit
	push		af
	call		ReadBCDByte
	res		7, a
	push		af
	call		ReadBCDByte
	res		7, a
	ld		e, a
	call		ReadBCDByte
	res		7, a
	ld		d, a
	call		ReadBCDByte
	res		7, a
	ld		c, a
	call		ReadBCDByte
	res		7, a
	ld		b, a
	pop		af
	ld		l, a
	pop		af
	ld		h, a
	call		RTC_WRITE
	ret

BuildTimeStr:
	push		hl
	call		RTC_READ
	pop		hl
	push		bc
	ld		a, d
	call WriteComponent
	ld (hl), ":"
	inc hl
	ld		a, c
	call WriteComponent
	ld (hl), ":"
	inc hl
	pop 		bc
	ld		a, b
	call WriteComponent
	ld (hl), "\n"
	inc hl
	ld (hl), "\r"
	inc hl
	ld (hl), "\0"
	inc hl
	ret

WriteComponent:
	ld b, a			; Copy
	srl a			; Shift down 10 digi
	srl a
	srl a
	srl a
	and 00000111b		; Mask off AM/PM
	add a, 48			; Convert to  ASCII
	ld (hl), a
	inc hl
	ld a, b
	and 00001111b
	add a, 48	; ASCII
	ld (hl), a
	inc hl
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Ls:
	ld	hl,0x0000
	ld	(file_count), hl
	ld	(total_size), hl
	ld	(total_size+2), hl
	ld	hl, LsLoopCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, NullCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, LsEndCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

LsLoopCallback:
	ld	hl, (file_count)
	inc	hl
	ld	(file_count), hl
	ld	hl, (total_size)
	ld	de, (size_in_bytes)
	add	hl, de
	ld	(total_size), hl
	ld	hl, (total_size+2)
	ld	de, 0
	adc	hl, de
	ld	(total_size+2), hl
	ld	hl, filename_buffer
	ld	a, " "
	ld	b, 12
LsBlankingLoop:
	ld	(hl), a
	inc	hl
	djnz	LsBlankingLoop
	call	BuildFilenameString
	ld	hl, filename_buffer
	ld	de, message_buffer
	ld	bc, 12
	ldir
	ex	de,hl
	ld	(hl), "\t"
	inc	hl
	ld	(hl), "\t"
	inc	hl
	ld	de, (size_in_bytes)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld	(hl), "\0"
	ld	hl, message_buffer
	call	PrintStringA
	ld	hl, BytesStr
	call	PrintStringA
	ret

LsEndCallback:
	ld	hl, TotalStr
	call	PrintStringA
	ld	hl, message_buffer
	ld	de, (file_count)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld	(hl), "\0"
	ld	hl, message_buffer
	call	PrintStringA
	ld	hl, FilesStr
	call	PrintStringA

	ld	hl, BytesLeadStr
	call	PrintStringA
	ld	hl, message_buffer
	ld	de, (total_size+2)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld	de, (total_size)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld	(hl), "\0"
	ld	hl, message_buffer
	call	PrintStringA
	ld	hl, BytesStr
	call	PrintStringA
	ret

TotalStr:
	defm	"\nTotal:\t\t\t\0"
FilesStr:
	defm	" files\r\n\0"
BytesLeadStr:
	defm	"\t\t\t\0"
BytesStr:
	defm	" bytes\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DosHelp:
	ld hl, dos_helpmessage
	call PrintStringA
	ret
	dos_helpmessage:	defm "LM-512 DOS commands:\n\r"
	defm "BATCH: Execute commands from text file.\n\r"
	defm "CP: Copy file.\n\r"
	defm "DATE: Print current date and time.\n\r"
	defm "LS: List directory contents.\n\r"
	defm "MONITOR: Enter machine code monitore.\n\r"
	defm "MV: Move (rename) file.\n\r"
	defm "RECEIVE FILENAME: Read data from serial port 2 and saveto FILENAME.\n\r"
	defm "RESET: Reset system.\n\r"
	defm "RM: remove file.\n\r"
	defm "SERLOAD ADR: Read data from serial port 2 to address ADR.\n\r"
	defm "SLEEP SEC: Sleep for SEC seconds.\n\r"
	defm "TYPE: Show file contents.\n\r"
	defm "UPTIME: Print system uptime in seconds.\n\r"
	defm "\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EnterMonitor:
	call		Monitor
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

proto_hello: equ $00
proto_hello_ack: equ $0F
proto_bytes: equ $F0
proto_send:  equ $FF

SerialLoad:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, SerialLoad00
	ld		hl, SerialLoadArgcErrorStr
	call		PrintStringA
	ret
SerialLoadArgcErrorStr:
	defm		"SERLOAD expects exactly one arg (4 digit hex address)\r\n\0"
SerialLoad00:
	; Validate address
	ld		hl, (dos_argv)
	call		ValidateAddress
	ret		nz
	; Parse address and store in HL
	call		Read16bit
	ld		h, b
	ld		l, c
SerialLoadCore:
	; Track how many bytes we receive
	ld		de, 0x0000
	; Reset server
	ld		a, proto_hello
	call		SERIAL_WRITE_B
	call		SERIAL_READ_B
	cp		proto_hello_ack
	jp		z, SerialLoad01
SerialLoad01:
transfer_outer_loop:
	ld		a, proto_bytes
	call		SERIAL_WRITE_B
	call		SERIAL_READ_B
	; A now contains byte count.  Turn to 16 bit in BC
	ld		b, 0
	ld		c, a
	; Increment byte received count
	ex		de, hl
	add		hl, bc
	ex		de, hl
	; Make sure we wren't just told there are no more bytes
	cp		0
	jp		z, SerialLoadEnd
	ld		a, proto_send
	call		SERIAL_WRITE_B
transfer_inner_loop:
	call		SERIAL_READ_B
	ld		(hl), a
	inc		hl
	dec		c
	ld		a, c
	cp		0
	jr		nz, transfer_inner_loop
	ld		a, "."
	call		SERIAL_WRITE_A
	jr		transfer_outer_loop
SerialLoadEnd:
	ld		hl, message_buffer
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\0"
	ld		hl, message_buffer
	call		PrintStringA
	ld		hl, SerialLoadStr
	call		PrintStringA
	ret
SerialLoadStr:
	defm		" bytes transferred.\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RECEIVE FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Receive:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, ReceiveValidate
	ld		hl, ReceiveArgcErrorStr
	call		PrintStringA
	ret
ReceiveArgcErrorStr:
	defm		"RECEIVE expects exactly one arg (8.3 filename)\r\n\0"
ReceiveValidate:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	;; First download the file
	ld		hl, 0x8000
	call		SerialLoadCore
	;; Now save
	ld		hl, 0x8000
	push		de
	pop		bc
	ld		de, (dos_argv)
	call		WriteFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RESET
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Reset:
	jp		0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; RENAME FILE (MV)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Mv:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		2
	jr		z, Mv00
	ld		hl, MvArgcErrorStr
	call		PrintStringA
	ret
MvArgcErrorStr:
	defm		"MV expects exactly two args (both 8.3 filenames)\r\n\0"
Mv00:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	ld		hl, (dos_argv+2)
	call		ValidateFilename
	ret		nz
	; HL points to a filename we want to rename
	ld	hl, (dos_argv)
	ld	(target_filename_ptr), hl
	; Setup to walk root dir
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, RenameCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

MatchFilenameCallback:
	call	BuildFilenameString
	ld	(hl), "\0"		; BuildFilenameString doesn't terminate!
	ld	hl, filename_buffer
	ld	de, (target_filename_ptr)
	call	StrictStrCmp
	ret	nz
	; At this point, we've matched
	; Let the directory walker know we can break out of the loop
	ld	a, 0xFF
	ld	(dir_walk_breakout), a
	ret

RenameCallback:
	; Dent *should* now be pointed at our target
	; Copy the new name into the filename buffer
	ld	hl, (dos_argv+2)
	ld	de, filename_buffer
	ld	bc, 16
	ldir
	; Overwrite the filename in the dent buffer
	call	ReverseBuildFilenameString
	; Save new dent to disk
	call	UpdateRootDir
	call	SaveRootDir
	ret

BadFileCallback:
	ld	hl, BadFileMsg
	call	PrintStringA
	ret
BadFileMsg:
	defm	"Bad command or filename.\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REMOVE FILE (RM)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Rm:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		1
	jr		z, RmValidate
	ld		hl, RmArgcErrorStr
	call		PrintStringA
	ret
RmArgcErrorStr:
	defm		"RM expects exactly one arg (filename)\r\n\0"
RmValidate:
	ld	hl, (dos_argv)
	ld	(target_filename_ptr), hl
	call		ValidateFilename
	ret		nz
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, RmCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

RmCallback:
	; First, remove the directory entry
	call	MakeAvailEntry
	call	UpdateRootDir
	call	SaveRootDir
	; Now free up the blocks in the FAT
	ld	hl, (starting_cluster)
	call	SeekCluster
RmLoop:
	call	TestEOF
	push	af			; Preserve results of EOF test
	ld	hl, (fat_mem_index)	; Get pointer to current cluster
	ld	e, (hl)			; Read next cluster into DE
	inc	hl
	ld	d, (hl)
	push	de
	;; Mark this cluster free
	ld	hl, (fat_mem_index)
	ld	a, 0x00
	ld	(hl), a
	inc	hl
	ld	(hl), a
	call	SaveFat
	;; Get next cluster back in HL
	pop	hl
	pop	AF			; Restore results of EOF test
	ret	z			; If this was the last cluster, return
	call	SeekCluster		; Otherwise, jump to the next
	jr	nz,RmLoop
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COPY FILE (CP)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Cp:
	; Check dos_argc
	ld		a, (dos_argc)
	cp		2
	jr		z, Cp00
	ld		hl, CpArgcErrorStr
	call		PrintStringA
	ret
CpArgcErrorStr:
	defm		"CP expects exactly two args (both 8.3 filenames)\r\n\0"
Cp00:
	ld		hl, (dos_argv)
	call		ValidateFilename
	ret		nz
	ld		hl, (dos_argv+2)
	call		ValidateFilename
	ret		nz
	ld	hl, (dos_argv)
	call	LoadFile
	ld	hl, 0x8000
	ld	de, (dos_argv+2)
	ld	bc, (size_in_bytes)
	call	WriteFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; LOAD FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DosLoadFile:
	ld		hl, (dos_argv)

LoadFile:
	; HL points to a filename we want to load
	; Save it for later
	ld	(target_filename_ptr), hl
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, LoadCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

LoadCallback:
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x8000
	call	ReadFile
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; EXEC FILE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ExecFile:
	ld		hl, dos_linebuf
	; HL points to a filename we want to load
	; Save it for later
	ld	(target_filename_ptr), hl
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, ExecCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

ExecCallback:
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x8000
	call	ReadFile
	call	0x8000		; Execute the loaded file
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TYPE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Type:
	ld		a, (dos_argc)
	cp		1
	jr		z, TypeValidate
	ld		hl, TypeArgcErrorStr
	call		PrintStringA
	ret
TypeArgcErrorStr:
	defm		"TYPE expects exactly one arg (filename)\r\n\0"
TypeValidate:
	ld	hl, (dos_argv)
	ld	(target_filename_ptr), hl
	call		ValidateFilename
	ret		nz
	; HL points to a filename we want to load
	; Save it for later
	ld	hl, MatchFilenameCallback
	ld	(dir_walk_loop_callback), hl
	ld	hl, TypeCallback
	ld	(dir_walk_break_callback), hl
	ld	hl, BadFileCallback
	ld	(dir_walk_end_callback), hl
	call	WalkRootDir
	ret

TypeCallback:
	; At this point, we've matched
	; Read the file into memory
	ld	hl, 0x8000
	call	ReadFile
	ld	hl, 0x8000
	ld	de, (size_in_bytes)
TypeLoop:
	ld	a, (hl)
	cp	0x0A	; newline
	jr	z, TypeNewline
	call	SERIAL_WRITE_A
TypeIncrement:
	inc	hl
	dec	de
	ld	a, d
	or	e
	jr	nz, TypeLoop
	ret
TypeNewline:
	ld	a, "\r"
	call	SERIAL_WRITE_A
	ld	a, "\n"
	call	SERIAL_WRITE_A
	jr	TypeIncrement

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TIMING STUFF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SleepDos:
	ld		a, (dos_argc)
	cp		1
	jr		z, SleepDos00
	ld		hl, SleepDosArgcErrorStr
	call		PrintStringA
	ret
SleepDosArgcErrorStr:
	defm		"SLEEP expects exactly one arg (2 digit hex second count)\r\n\0"
SleepDos00:
	; Validate address
	ld		hl, (dos_argv)
	call		ValidateValue
	ret		nz
	; Parse address and store in HL
	call		Read8bit
	call		Sleep
	ret

Uptime:
	ld		hl, dos_linebuf
	ld		de, (uptime)
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	call		TerminateLine
	ld		hl, dos_linebuf
	call		PrintStringA
