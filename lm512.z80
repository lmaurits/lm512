; Definitional includes
include 'memmap.z80'
include 'iomap.z80'

	org		ROMBASE
	ld		sp, SYSSTACK
	jp		Main

; Code generating includes
;include 'debug.z80'
include 'uart.z80'
include 'cf.z80'
include 'rtc.z80'
include 'string.z80'

Main:
	; Initialise hardware
	call UartInit

	; Print welcome message
	ld hl, welcomestr
	call PrintStringA
	jp Monitor
	welcomestr: defm "Welcome to LM-512 microcomputer system.\n\r\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMAND LINE INTERFACE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Infinite loop of read, parse, dispatch
Monitor:
	ld hl, promptstr
	call PrintStringA
	ld hl, linebuf
	call ReadLineA
	ld hl, linebuf
	ld a, (hl)
	cp		"\0"
	jr		z, Monitor
	call MonitorHandleLine
	jr Monitor
	promptstr: defm "> \0"

MonitorHandleLine:
	ld		hl, linebuf	
	call		ConvertToUpper
	call		ParseLine
	call		Dispatch
	ret

ParseLine:
	; Prepare to read arguments
	; Set argc to 0
	ld		a, 0
	ld		(argc), a
	; Set argv_index to argv
	ld		hl, argv_index
	ld		de, argv
	ld		(hl), e
	inc		hl
	ld		(hl), d
	; Read command name
	ld		hl, linebuf
	call StrTok
ParseLine00:
	; If string ended in a null, we're done
	cp		"\0"
	ret		z
	; Put HL into argv and increment argv_index
	ld		hl, (argv_index)
	ld		(hl), e
	inc		hl
	ld		(hl), d
	inc		hl
	ld		(argv_index), hl
	; Increment argc
	ld		a, (argc)
	inc		a
	ld		(argc), a
	; Prepare for next StrTok...
	ld		h, d
	ld		l, e
	call		StrTok
	jr		ParseLine00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND DISPATCH
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Command strings

cfloadstr:	defm "CFLOAD\0"
cfsavestr:	defm "CFSAVE\0"
bankstr:	defm "BANK\0"
datestr:	defm "DATE\0"
dumpstr:	defm "DUMP\0"
instr:		defm "IN\0"
helpstr:	defm "HELP\0"
jumpstr:	defm "JUMP\0"
memcpystr:	defm "MEMCPY\0"
outstr:		defm "OUT\0"
peekstr:	defm "PEEK\0"
pokestr:	defm "POKE\0"
serloadstr:	defm "SERLOAD\0"
nullstr:	defm "\0"

; Table linking command strings to function entry points
dispatch_table:
	defw cfloadstr, CfLoad
	defw cfsavestr, CfSave
	defw bankstr, Bank
	defw datestr, Date
	defw dumpstr, Dump
	defw instr, In
	defw helpstr, Help
	defw jumpstr, Jump
	defw memcpystr, Memcpy
	defw outstr, Out
	defw peekstr, Peek
	defw pokestr, Poke
	defw serloadstr, SerialLoad
	defw nullstr, What

; Function which interprets the string pointed to by HL
; as a command and calls the appropriate function
Dispatch:
	ld		hl, dispatch_table
	ld		(dispatch_index), hl
Dispatch00:
	ld		a, (hl)			; read first byte of string add into a
	ld		e, a			; stick it in e
	inc		hl			; advance
	ld		a, (hl)			; read second byte
	ld		d, a			; stick it in d

	ld		h, d
	ld		l, e

	ld		hl, linebuf		; point HL at start of command
	call		StrCmp
	jr		z, Dispatch01		; We've matched!
	ld		hl, (dispatch_index)	; put index address in HL
	inc		hl	
	inc		hl	
	inc		hl	
	inc		hl	
	ld		(dispatch_index), hl	
	jr		Dispatch00
Dispatch01:
	ld		de, (dispatch_index)	
	inc		de	
	inc		de
	ld		a, (de)
	ld		l, a
	inc		de
	ld		a, (de)
	ld		h, a
	jp		(hl)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MONITOR COMMANDS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Bank:
	ld		a, (argc)
	cp		1
	jr		z, Bank00
	ld		hl, BankErrStr
	call		PrintStringA
	ret
BankErrStr:
	defm		"BANK expects exactly one arg (2 digit hex bank)\r\n\0"
Bank00:
	ld		hl, (argv)
	call		ValidateValue
	jr		z, Bank01
	ret
Bank01:
	call		Read8bit	
	out		(0), a
	ret
FooStr: defm		"Foo\r\n\0"
BarStr: defm		"Bar\r\n\0"
BazStr: defm		"Baz\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfLoad:
	; Check argument count
	ld		a, (argc)
	cp		3
	jr		z, CfLoad00
	ld		hl, CfLoadErrorStr
	call		PrintStringA
	ret
CfLoad00:
	; Validate address
	ld		hl, (argv)
	call		ValidateAddress
	ret		nz
	; Convert and stash address
	call		Read16bit
	push		bc
	; Validate sector
	ld		hl, (argv+2)
	call		ValidateSector
	ret		nz
	call		CfSetup
	call		Read16bit
	push		bc
	call		Read16bit
	pop		de
	call		SetLBA
	; Validate value
	ld		hl, (argv+4)
	call		ValidateValue
	jr		z, CfLoad01
	pop		bc
	ret
CfLoad01:
	; Convert and stash value
	call		Read8bit
	push		af
	; Set sector count
	call		SetSectorCount
	; Read to CF's buffer
	call		SendReadCommand
	; Retreive loading address
	pop		af	; sector count in a
	pop		hl	; start address
CfLoad02:
	ld		b, a
	call		WaitBusyData
	ld		a, b
	ld		c, 32	; port address
	ld		b, 0	; read 256 bytes
	inir
	inir			; read second half of sector
	dec		a
	cp		0
	jr		nz, CfLoad02
	ret
CfLoadErrorStr:
	defm		"CFLOAD expects exactly three args (A 4 digit hex destination address, a 6 digit hex start sector and a 2 digit hex sector count)\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CfSave:
	; Check argument count
	ld		a, (argc)
	cp		3
	jr		z, CfSave00
	ld		hl, CfSaveErrorStr
	call		PrintStringA
	ret
CfSave00:
	; Validate sector
	ld		hl, (argv)
	call		ValidateSector
	ret		nz
	call		CfSetup
	call		Read16bit
	push		bc
	call		Read16bit
	pop		de
	call		SetLBA
	; Validate address
	ld		hl, (argv+2)
	call		ValidateAddress
	ret		nz
	; Convert and stash address
	call		Read16bit
	push		bc
	; Validate value
	ld		hl, (argv+4)
	call		ValidateValue
	jr		z, CfSave01
	pop		bc	; Get rid of stacked bc before ret
	ret
CfSave01:
	; Convert and stash value
	call		Read8bit
	push		af
	; Set sector count
	call		SetSectorCount
	; Tell drive we want to write
	call		SendWriteCommand
	; Retreive loading address
	pop		af	; sector count in a
	pop		hl	; start address in hl
CfSave02:
	ld		b, a
	call		WaitBusyData
	ld		a, b
	ld		c, 32	; port address
	ld		b, 0	; read 256 bytes
	otir
	otir			; read second half of sector
	dec		a
	cp		0
	jr		nz, CfSave02
	ret
CfSaveErrorStr:
	defm		"CFSAVE expects exactly three args (a 6 digit hex start sector, a 4 digit start address and a 2 digit hex sector count)\r\n\0"


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Date:
	ld		a, (argc)
	cp		0
	jr		z, DateGet
	cp		1
	jr		z, DateSet
	ld		hl, DateArgcErrStr
	call		PrintStringA
	ret
DateArgcErrStr:
	defm		"Date expects zero arguments (to get) or one argument (to set, YYMMDDHHmmSS)\r\n\0"
DateSet:
	ld		hl, (argv)
	call		ValidateDateString
	ret		nz
	call		SetTimeFromString
DateGet:
	ld hl, linebuf
	call BuildTimeStr
	ld hl, linebuf
	call PrintStringA
	ret
ValidateDateString:
	call		StrLen
	cp		12
	jr		nz, ValidateDateStringErr
	call		IsStrDec
	jr		nz, ValidateDateStringErr
ValidateDateStringOkay:
	cp		a	; Set zero flag
	ret
ValidateDateStringErr:
	ld		hl, ValidateDateStringErrStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
ValidateDateStringErrStr:
	defm		"Date setting requires a 12 digit decimal string in YYMMDDHHmmSS format\r\n\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Dump:
	; Check argument count
	ld		a, (argc)
	cp		1
	jr		z, Dump00
	ld		hl, DumpArgcErrorStr
	call		PrintStringA
	ret
DumpArgcErrorStr:
	defm		"DUMP expects exactly one arg (4 digit hex address)\r\n\0"
Dump00:
	ld		hl, (argv)
	call		ValidateAddress
	jr		z, Dump01
	ret
Dump01:
	call		Read16bit	; Read address into BC
	ld		d, b
	ld		e, c
	ld		b, 16
	push		bc
DumpOuter:
	ld		hl, linebuf
	ld		b, 16
DumpInner:
	ld		a, d
	call		StrfHex
	ld		a, e
	call		StrfHex
	ld		(hl), "\t"
	inc		hl
DumpInner2:
	ld		a, (de)		; Read from BC to A
	inc		de
	call		StrfHex
	ld		(hl), " "
	inc		hl
	dec		b
	ld		a, b
	cp		0
	jr		z, Dump03
	jr		DumpInner2
Dump03:
	call		TerminateLine
	ld		hl, linebuf
	call		PrintStringA
	pop		bc
	dec		b
	ld		a, b
	cp		0
	ret		z
	push		bc
	jr		DumpOuter

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

In:
	ld		a, (argc)
	cp		1
	jr		z, In00
	ld		hl, InErrStr
	call		PrintStringA
	ret
InErrStr:
	defm		"IN expects exactly one arg (2 digit hex address)\r\n\0"
In00:
	call		Read8bit
	ld		c, a
	in		a, (c)
	ld		hl, linebuf	; Point to start of output
	call		StrfHex		; Write hex string
	call		TerminateLine	; Add \n\r\0
	ld		hl, linebuf	; Print output
	call		PrintStringA
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Help:
	ld hl, helpmessage
	call PrintStringA
	ret
	helpmessage:	defm "LM-512 Monitor commands:\n\r"
	defm "BANK PG: Switch highest 32KB to bank PG.\n\r"
	defm "CFLOAD ADR STARTSEC SECS: Read SECS 512 byte sectors from CF card, starting from STARTSEC, to address ADR.\n\r"
	defm "DATE: Print current date and time.\n\r"
	defm "DUMP ADR: Dump 256 bytes of memory starting from ADR in hex format.\n\r"
	defm "HELP: Print this help message.\n\r"
	defm "IN PORT: Read byte from given I/O port.\n\r"
	defm "JUMP ADR: Jump to address.\n\r"
	defm "MEMCPY DEST SRC BYTES: Copy BYTES consecutive bytes from SRC to DEST\n\r"
	defm "OUT PORT VAL: Write byte VAL to given I/O port.\n\r"
	defm "PEEK ADR: Print byte stored at address ADR.\n\r"
	defm "POKE ADR VAL: Store byte VAL at address ADR.\n\r"
	defm "SERLOAD ADR: Read data from serial port 2 to address ADR.\n\r\0"
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Jump:
	ld		a, (argc)
	cp		1
	jr		z, Jump00
	ld		hl, JumpErrStr
	call		PrintStringA
	ret
JumpErrStr:
	defm		"JUMP expects exactly one arg (4 digit hex address)\r\n\0"
Jump00:
	ld		hl, (argv)
	call		ValidateAddress
	jr		z, Jump01
	ret
Jump01:
	call		Read16bit
	ld		h, b
	ld		l, c
	jp		(hl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Memcpy:
	ld		a, (argc)
	cp		3
	jr		z, Memcpy00
	ld		hl, MemcpyArgcErrStr
	call		PrintStringA
	ret
MemcpyArgcErrStr:
	defm		"MEMCPY expects exactly three args (Two 4 digit hex addresses and one 4 digit hex byte count\r\n\0"
Memcpy00:
	; Validate, parse and push destination
	ld		hl, (argv)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	push		bc	
	; Validate, parse and push source
	ld		hl, (argv+2)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	push		bc	
	; Validate, parse and push count
	ld		hl, (argv+4)
	call		ValidateAddress
	ret		nz
	call		Read16bit
	pop		hl
	pop		de
	ldir
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Out:
	ld		a, (argc)
	cp		2
	jr		z, Out00
	ld		hl, OutErrStr
	call		PrintStringA
	ret
OutErrStr:
	defm		"OUT expects exactly two args (A 2 digit hex address, a 2 digit hex value)\r\n\0"
Out00:
	ld		hl, (argv)
	call		ValidateValue
	jr		z, Out01
	ret
Out01:
	ld		hl, (argv+2)
	call		ValidateValue
	jr		z, Out02
	ret
Out02:
	ld		hl, (argv)
	call		Read8bit
	ld		c, a
	ld		hl, (argv+2)
	call		Read8bit
	out		(c), a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Peek:
	; Check argument count
	ld		a, (argc)
	cp		1
	jr		z, Peek00
	ld		hl, PeekArgcErrorStr
	call		PrintStringA
	ret
PeekArgcErrorStr:
	defm		"PEEK expects exactly one arg (4 digit hex address)\r\n\0"
Peek00:
	ld		hl, (argv)
	call		ValidateAddress
	jr		z, Peek01
	ret
Peek01:
	call		Read16bit	; Read address into BC
	ld		a, (bc)		; Read from BC to A
	ld		hl, linebuf	; Point to start of output
	call		StrfHex		; Write hex string
	call		TerminateLine	; Add \n\r\0
	ld		hl, linebuf	; Print output
	call		PrintStringA
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Poke:
	; Check argument count
	ld		a, (argc)
	cp		2
	jr		z, Poke00
	ld		hl, PokeArgcErrorStr
	call		PrintStringA
	ret
PokeArgcErrorStr:
	defm		"POKE expects exactly two args (A 4 digit hex address, a 2 digit hex value)\r\n\0"
Poke00:
	; Validate address
	ld		hl, (argv)
	call		ValidateAddress
	ret		nz
	; Convert and stash address
	call		Read16bit
	push		bc
	; Validate value
	ld		hl, (argv+2)
	call		ValidateValue
	ret		nz
	; Convert value
	call		Read8bit
	; Recover address
	pop		hl
	; Do it
	ld		(hl), a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

proto_hello: equ $00
proto_hello_ack: equ $0F
proto_bytes: equ $F0
proto_send:  equ $FF

SerialLoad:
	; Check argc
	ld		a, (argc)
	cp		1
	jr		z, SerialLoad00
	ld		hl, SerialLoadArgcErrorStr
	call		PrintStringA
	ret
SerialLoadArgcErrorStr:
	defm		"SERLOAD expects exactly one arg (4 digit hex address)\r\n\0"
SerialLoad00:
	; Validate address
	ld		hl, (argv)
	call		ValidateAddress
	ret		nz
	; Parse address and store in HL
	call		Read16bit
	ld		h, b
	ld		l, c
	; Reset server
	ld		a, proto_hello
	call		WriteB
	call		ReadB
	cp		proto_hello_ack
	jp		z, SerialLoad01
SerialLoad01:
transfer_outer_loop:
	ld		a, proto_bytes
	call		WriteB
	call		ReadB
	ld c, a
	cp 0
	ret		z
	push		bc
	ld		a, proto_send
	call		WriteB
transfer_inner_loop:
	call		ReadB
	ld		(hl), a
	inc		hl
	dec		c
	ld		a, c
	cp		0
	jr		nz, transfer_inner_loop
	pop		bc
	push		hl
	ld		a, c
	ld		hl, linebuf
	call		StrfHex
	ld		(hl), "\0"
	ld		hl, linebuf
	call		PrintStringA
	ld		hl, SerialLoadStr
	call		PrintStringA
	pop		hl
	jr		transfer_outer_loop
SerialLoadStr:
	defm		" bytes transferred.\r\n\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

What:
	ld hl, whatstr
	call PrintStringA
	ret
	whatstr: defm "What?\n\r\0"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; UTILITY FUNCTIONS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ValidateValue:
	call		StrLen
	cp		2
	jr		nz, ValidateValueError
	call		IsStrHex
	jr		nz, ValidateValueError
	cp		a	; Set zero flag
	ret
ValidateValueError:
	call		PrintStringA
	ld		hl, ValueErrorStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
ValueErrorStr:
	defm		" is not a valid value.  Use 2 digit hex, 00 to FF.\r\n\0"

ValidateAddress:
	call		StrLen
	cp		4
	jr		nz, ValidateAddressError
	call		IsStrHex
	jr		nz, ValidateAddressError
	cp		a	; Set zero flag
	ret
ValidateAddressError:
	call		PrintStringA
	ld		hl, AddressErrorStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
AddressErrorStr:
	defm		" is not a valid address.  Use 4 digit hex, 0000 to FFFF.\r\n\0"

ValidateSector:
	call		StrLen
	cp		8
	jr		nz, ValidateSectorError
	call		IsStrHex
	jr		nz, ValidateSectorError
	cp		a	; Set zero flag
	ret
ValidateSectorError:
	call		PrintStringA
	ld		hl, SectorErrorStr
	call		PrintStringA
	or		1	; Reset zero flag
	ret
SectorErrorStr:
	defm		" is not a valid sector.  Use 8 digit hex, 00000000 to 100000.\r\n\0"
